<html xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cdf="http://checklists.nist.gov/xccdf/1.1" xmlns:xhtml="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title> Rules with
			cis
			Reference in Guide to the Secure Configuration of Red Hat Enterprise Linux 7</title>
</head>
<body>
<br><br><div style="text-align: center; font-size: x-large; font-weight:bold">
			Rules with  cis Reference in Guide to the Secure Configuration of Red Hat Enterprise Linux 7</div>
<br><br><style type="text/css">
		table
		{
			border-collapse:collapse;
		}
		table, th, td
		{
			border: 2px solid #dcdcdc;
			border-left: none;
			border-right: none;
			vertical-align: top;
			padding: 2px;
			font-family: verdana,arial,sans-serif;
			font-size:11px;
		}
		pre { 
			white-space: pre-wrap;
			white-space: -moz-pre-wrap !important;
			word-wrap:break-word; 
		}
		table tr:nth-child(2n+2) { background-color: #f4f4f4; }
		thead
		{
			display: table-header-group;
			font-weight: bold;
			background-color: #dedede;
		}
	</style>
<table>
<thead>
<td>Reference (cis)</td>
<td>Rule Title</td>
<td>Description</td>
<td>Rationale</td>
<td>Variable Setting</td>
</thead>
<tr>
<td>1.7.1.5</td>
<td>Verify Group Ownership of System Login Banner</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/issue</code>, run the command:
<pre>$ sudo chgrp root /etc/issue</pre>
</td>
<td xml:lang="en-US">Display of a standardized and approved use notification before granting
access to the operating system ensures privacy and security notification
verbiage used is consistent with applicable federal laws, Executive Orders,
directives, policies, regulations, standards, and guidance.<br>
Proper group ownership will ensure that only root user can modify the banner.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.4</td>
<td>Verify ownership of Message of the Day Banner</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/motd</code>, run the command:
<pre>$ sudo chown root /etc/motd </pre>
</td>
<td xml:lang="en-US">Display of a standardized and approved use notification before granting
access to the operating system ensures privacy and security notification
verbiage used is consistent with applicable federal laws, Executive Orders,
directives, policies, regulations, standards, and guidance.<br>
Proper ownership will ensure that only root user can modify the banner.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.5</td>
<td>Verify permissions on System Login Banner</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/issue</code>, run the command:
<pre>$ sudo chmod 0644 /etc/issue</pre>
</td>
<td xml:lang="en-US">Display of a standardized and approved use notification before granting
access to the operating system ensures privacy and security notification
verbiage used is consistent with applicable federal laws, Executive Orders,
directives, policies, regulations, standards, and guidance.<br>
Proper permissions will ensure that only root user can modify the banner.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.4</td>
<td>Verify Group Ownership of Message of the Day Banner</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/motd</code>, run the command:
<pre>$ sudo chgrp root /etc/motd</pre>
</td>
<td xml:lang="en-US">Display of a standardized and approved use notification before granting
access to the operating system ensures privacy and security notification
verbiage used is consistent with applicable federal laws, Executive Orders,
directives, policies, regulations, standards, and guidance.<br>
Proper group ownership will ensure that only root user can modify the banner.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.4</td>
<td>Verify permissions on Message of the Day Banner</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/motd</code>, run the command:
<pre>$ sudo chmod 0644 /etc/motd</pre>
</td>
<td xml:lang="en-US">Display of a standardized and approved use notification before granting
access to the operating system ensures privacy and security notification
verbiage used is consistent with applicable federal laws, Executive Orders,
directives, policies, regulations, standards, and guidance.<br>
Proper permissions will ensure that only root user can modify the banner.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.5</td>
<td>Verify ownership of System Login Banner</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/issue</code>, run the command:
<pre>$ sudo chown root /etc/issue </pre>
</td>
<td xml:lang="en-US">Display of a standardized and approved use notification before granting
access to the operating system ensures privacy and security notification
verbiage used is consistent with applicable federal laws, Executive Orders,
directives, policies, regulations, standards, and guidance.<br>
Proper ownership will ensure that only root user can modify the banner.</td>
<td></td>
</tr>
<tr>
<td>6.3.1</td>
<td>Set Password Hashing Algorithm in /etc/login.defs</td>
<td xml:lang="en-US">In <code>/etc/login.defs</code>, add or correct the following line to ensure
the system will use SHA-512 as the hashing algorithm:
<pre>ENCRYPT_METHOD SHA512</pre>
</td>
<td xml:lang="en-US">Passwords need to be protected at all times, and encryption is the standard method for protecting passwords.
If passwords are not encrypted, they can be plainly read (i.e., clear text) and easily compromised. Passwords
that are encrypted with a weak algorithm are no more protected than if they are kept in plain text.
<br><br>
Using a stronger hashing algorithm makes password cracking attacks more difficult.</td>
<td></td>
</tr>
<tr>
<td>6.3.2</td>
<td>Ensure PAM Enforces Password Requirements - Minimum Digit Characters</td>
<td xml:lang="en-US">The pam_pwquality module's <code>dcredit</code> parameter controls requirements for
usage of digits in a password. When set to a negative number, any password will be required to
contain that many digits. When set to a positive number, pam_pwquality will grant +1 additional
length credit for each digit. Modify the <code>dcredit</code> setting in
<code>/etc/security/pwquality.conf</code> to require the use of a digit in passwords.</td>
<td xml:lang="en-US">Use of a complex password helps to increase the time and resources required
to compromise the password. Password complexity, or strength, is a measure of
the effectiveness of a password in resisting attempts at guessing and brute-force
attacks.
<br><br>
Password complexity is one factor of several that determines how long it takes
to crack a password. The more complex the password, the greater the number of
possible combinations that need to be tested before the password is compromised.
Requiring digits makes password guessing attacks more difficult by ensuring a larger
search space.</td>
<td></td>
</tr>
<tr>
<td>6.3.2</td>
<td>Ensure PAM Enforces Password Requirements - Minimum Length</td>
<td xml:lang="en-US">The pam_pwquality module's <code>minlen</code> parameter controls requirements for
minimum characters required in a password. Add <code>minlen=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_password_pam_minlen"></xccdf-1.1:sub></code>
after pam_pwquality to set minimum password length requirements.</td>
<td xml:lang="en-US">The shorter the password, the lower the number of possible combinations
that need to be tested before the password is compromised.
<br>
Password complexity, or strength, is a measure of the effectiveness of a
password in resisting attempts at guessing and brute-force attacks.
Password length is one factor of several that helps to determine strength
and how long it takes to crack a password. Use of more characters in a password
helps to exponentially increase the time and/or resources required to
compromose the password.</td>
<td></td>
</tr>
<tr>
<td>6.3.2</td>
<td>Ensure PAM Enforces Password Requirements - Authentication Retry Prompts Permitted Per-Session</td>
<td xml:lang="en-US">To configure the number of retry prompts that are permitted per-session:
Edit the <code>pam_pwquality.so</code> statement in <code>/etc/pam.d/system-auth</code> to
show <code>retry=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_password_pam_retry"></xccdf-1.1:sub></code>, or a lower value if
site policy is more restrictive.
The DoD requirement is a maximum of 3 prompts per session.</td>
<td xml:lang="en-US">Setting the password retry prompts that are permitted on a per-session basis to a low value
requires some software, such as SSH, to re-connect. This can slow down and
draw additional attention to some types of password-guessing attacks. Note that this
is different from account lockout, which is provided by the pam_faillock module.</td>
<td></td>
</tr>
<tr>
<td>6.3.2</td>
<td>Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters</td>
<td xml:lang="en-US">The pam_pwquality module's <code>ucredit=</code> parameter controls requirements for
usage of uppercase letters in a password. When set to a negative number, any password will be required to
contain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional
length credit for each uppercase character. Modify the <code>ucredit</code> setting in
<code>/etc/security/pwquality.conf</code> to require the use of an uppercase character in passwords.</td>
<td xml:lang="en-US">Use of a complex password helps to increase the time and resources reuiqred to compromise the password.
Password complexity, or strength, is a measure of the effectiveness of a password in resisting attempts
at guessing and brute-force attacks.
<br><br>
Password complexity is one factor of several that determines how long it takes to crack a password. The more
complex the password, the greater the number of possible combinations that need to be tested before
the password is compromised.</td>
<td></td>
</tr>
<tr>
<td>5.3.3</td>
<td>Limit Password Reuse</td>
<td xml:lang="en-US">Do not allow users to reuse recent passwords. This can be
accomplished by using the <code>remember</code> option for the <code>pam_unix</code>
or <code>pam_pwhistory</code> PAM modules.
<br><br>
In the file <code>/etc/pam.d/system-auth</code>, append <code>remember=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_password_pam_unix_remember"></xccdf-1.1:sub></code>
to the line which refers to the <code>pam_unix.so</code> or <code>pam_pwhistory.so</code>module, as shown below:
<ul>
<li>for the <code>pam_unix.so</code> case:
<pre>password sufficient pam_unix.so <i>...existing_options...</i> remember=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_password_pam_unix_remember"></xccdf-1.1:sub></pre>
</li>
<li>for the <code>pam_pwhistory.so</code> case:
<pre>password requisite pam_pwhistory.so <i>...existing_options...</i> remember=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_password_pam_unix_remember"></xccdf-1.1:sub></pre>
</li>
</ul>
The DoD STIG requirement is 5 passwords.</td>
<td xml:lang="en-US">Preventing re-use of previous passwords helps ensure that a compromised password is not re-used by a user.</td>
<td></td>
</tr>
<tr>
<td>5.3.2</td>
<td>Set Deny For Failed Password Attempts</td>
<td xml:lang="en-US">To configure the system to lock out accounts after a number of incorrect login
attempts using <code>pam_faillock.so</code>, modify the content of both
<code>/etc/pam.d/system-auth</code> and <code>/etc/pam.d/password-auth</code> as follows:
<br><br>
<ul>
<li> add the following line immediately <code>before</code> the <code>pam_unix.so</code> statement in the <code>AUTH</code> section:
<pre>auth required pam_faillock.so preauth silent deny=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_deny"></xccdf-1.1:sub> unlock_time=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_unlock_time"></xccdf-1.1:sub> fail_interval=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_fail_interval"></xccdf-1.1:sub></pre>
</li>
<li> add the following line immediately <code>after</code> the <code>pam_unix.so</code> statement in the <code>AUTH</code> section:
<pre>auth [default=die] pam_faillock.so authfail deny=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_deny"></xccdf-1.1:sub> unlock_time=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_unlock_time"></xccdf-1.1:sub> fail_interval=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_fail_interval"></xccdf-1.1:sub></pre>
</li>
<li> add the following line immediately <code>before</code> the <code>pam_unix.so</code> statement in the <code>ACCOUNT</code> section:
<pre>account required pam_faillock.so</pre>
</li>
</ul>
</td>
<td xml:lang="en-US">Locking out user accounts after a number of incorrect attempts
prevents direct password guessing attacks.</td>
<td></td>
</tr>
<tr>
<td>5.3.2</td>
<td>Set Lockout Time for Failed Password Attempts</td>
<td xml:lang="en-US">To configure the system to lock out accounts after a number of incorrect login
attempts and require an administrator to unlock the account using <code>pam_faillock.so</code>,
modify the content of both <code>/etc/pam.d/system-auth</code> and <code>/etc/pam.d/password-auth</code> as follows:
<br><br>
<ul>
<li> add the following line immediately <code>before</code> the <code>pam_unix.so</code> statement in the <code>AUTH</code> section:
<pre>auth required pam_faillock.so preauth silent deny=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_deny"></xccdf-1.1:sub> unlock_time=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_unlock_time"></xccdf-1.1:sub> fail_interval=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_fail_interval"></xccdf-1.1:sub></pre>
</li>
<li> add the following line immediately <code>after</code> the <code>pam_unix.so</code> statement in the <code>AUTH</code> section:
<pre>auth [default=die] pam_faillock.so authfail deny=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_deny"></xccdf-1.1:sub> unlock_time=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_unlock_time"></xccdf-1.1:sub> fail_interval=<xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_passwords_pam_faillock_fail_interval"></xccdf-1.1:sub></pre>
</li>
<li> add the following line immediately <code>before</code> the <code>pam_unix.so</code> statement in the <code>ACCOUNT</code> section:
<pre>account required pam_faillock.so</pre>
</li>
</ul>
If <code>unlock_time</code> is set to <code>0</code>, manual intervention by an administrator is required to unlock a user.</td>
<td xml:lang="en-US">Locking out user accounts after a number of incorrect attempts
prevents direct password guessing attacks. Ensuring that an administrator is
involved in unlocking locked accounts draws appropriate attention to such
situations.</td>
<td></td>
</tr>
<tr>
<td>1.4.3</td>
<td>Require Authentication for Emergency Systemd Target</td>
<td xml:lang="en-US">Emergency mode is intended as a system recovery
method, providing a single user root access to the system
during a failed boot sequence.
<br><br>
By default, Emergency mode is protected by requiring a password and is set
in <code>/usr/lib/systemd/system/emergency.service</code>.</td>
<td xml:lang="en-US">This prevents attackers with physical access from trivially bypassing security
on the machine and gaining root access. Such accesses are further prevented
by configuring the bootloader password.</td>
<td></td>
</tr>
<tr>
<td>1.4.3</td>
<td>Require Authentication for Single User Mode</td>
<td xml:lang="en-US">Single-user mode is intended as a system recovery
method, providing a single user root access to the system by
providing a boot option at startup. By default, no authentication
is performed if single-user mode is selected.
<br><br>

By default, single-user mode is protected by requiring a password and is set
in <code>/usr/lib/systemd/system/rescue.service</code>.</td>
<td xml:lang="en-US">This prevents attackers with physical access from trivially bypassing security
on the machine and gaining root access. Such accesses are further prevented
by configuring the bootloader password.</td>
<td></td>
</tr>
<tr>
<td>6.2.2</td>
<td>Ensure there are no legacy + NIS entries in /etc/passwd</td>
<td xml:lang="en-US">The <code>+</code> character in <code>/etc/passwd</code> file marks a place where
entries from a network information service (NIS) should be directly inserted.</td>
<td xml:lang="en-US">Using this method to include entries into <code>/etc/passwd</code> is considered legacy
and should be avoided. These entries may provide a way for an attacker
to gain access to the system.</td>
<td></td>
</tr>
<tr>
<td>6.2.4</td>
<td>Ensure there are no legacy + NIS entries in /etc/group</td>
<td xml:lang="en-US">The <code>+</code> character in <code>/etc/group</code> file marks a place where
entries from a network information service (NIS) should be directly inserted.</td>
<td xml:lang="en-US">Using this method to include entries into <code>/etc/group</code> is considered legacy
and should be avoided. These entries may provide a way for an attacker
to gain access to the system.</td>
<td></td>
</tr>
<tr>
<td>6.2.3</td>
<td>Ensure there are no legacy + NIS entries in /etc/shadow</td>
<td xml:lang="en-US">The <code>+</code> character in <code>/etc/shadow</code> file marks a place where
entries from a network information service (NIS) should be directly inserted.</td>
<td xml:lang="en-US">Using this method to include entries into <code>/etc/shadow</code> is considered legacy
and should be avoided. These entries may provide a way for an attacker
to gain access to the system.</td>
<td></td>
</tr>
<tr>
<td>5.4.2</td>
<td>Ensure that System Accounts Do Not Run a Shell Upon Login</td>
<td xml:lang="en-US">Some accounts are not associated with a human user of the system, and exist to
perform some administrative function. Should an attacker be able to log into
these accounts, they should not be granted access to a shell.
<br><br>
The login shell for each local account is stored in the last field of each line
in <code>/etc/passwd</code>. System accounts are those user accounts with a user ID
less than UID_MIN, where value of UID_MIN directive is set in
/etc/login.defs configuration file. In the default configuration UID_MIN is set
to 1000, thus system accounts are those user accounts with a user ID less than
1000. The user ID is stored in the third field. If any system account
<i>SYSACCT</i> (other than root) has a login shell, disable it with the
command: <pre>$ sudo usermod -s /sbin/nologin <i>SYSACCT</i></pre>
</td>
<td xml:lang="en-US">Ensuring shells are not given to system accounts upon login makes it more
difficult for attackers to make use of system accounts.</td>
<td></td>
</tr>
<tr>
<td>5.4.4</td>
<td>Ensure the Default Umask is Set Correctly in /etc/profile</td>
<td xml:lang="en-US">To ensure the default umask controlled by <code>/etc/profile</code> is set properly,
add or correct the <code>umask</code> setting in <code>/etc/profile</code> to read as follows:
<pre>umask <xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_user_umask"></xccdf-1.1:sub></pre>
</td>
<td xml:lang="en-US">The umask value influences the permissions assigned to files when they are created.
A misconfigured umask value could result in files with excessive permissions that can be read or
written to by unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.4.4</td>
<td>Ensure the Default Bash Umask is Set Correctly</td>
<td xml:lang="en-US">To ensure the default umask for users of the Bash shell is set properly,
add or correct the <code>umask</code> setting in <code>/etc/bashrc</code> to read
as follows:
<pre>umask <xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_accounts_user_umask"></xccdf-1.1:sub></pre>
</td>
<td xml:lang="en-US">The umask value influences the permissions assigned to files when they are created.
A misconfigured umask value could result in files with excessive permissions that can be read or
written to by unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>4.1.18</td>
<td>Make the auditd Configuration Immutable</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code> in order to make the auditd configuration
immutable:
<pre>-e 2</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file in order to make the auditd configuration
immutable:
<pre>-e 2</pre>
With this setting, a reboot will be required to change any audit rules.</td>
<td xml:lang="en-US">Making the audit configuration immutable prevents accidental as
well as malicious modification of the audit rules, although it may be
problematic if legitimate changes are needed during system
operation</td>
<td></td>
</tr>
<tr>
<td>5.2.5</td>
<td>Record Events that Modify User/Group Information - /etc/passwd</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>
</td>
<td xml:lang="en-US">In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</td>
<td></td>
</tr>
<tr>
<td>5.2.5</td>
<td>Record Events that Modify User/Group Information</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, in order to capture events that modify
account changes:
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification
-w /etc/passwd -p wa -k audit_rules_usergroup_modification
-w /etc/gshadow -p wa -k audit_rules_usergroup_modification
-w /etc/shadow -p wa -k audit_rules_usergroup_modification
-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>
<br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file, in order to capture events that modify
account changes:
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification
-w /etc/passwd -p wa -k audit_rules_usergroup_modification
-w /etc/gshadow -p wa -k audit_rules_usergroup_modification
-w /etc/shadow -p wa -k audit_rules_usergroup_modification
-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>
</td>
<td xml:lang="en-US">In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</td>
<td></td>
</tr>
<tr>
<td>5.2.13</td>
<td>Ensure auditd Collects Information on Exporting to Media (successful)</td>
<td xml:lang="en-US">At a minimum, the audit system should collect media exportation
events for all users and root. If the <code>auditd</code> daemon is configured to
use the <code>augenrules</code> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <code>.rules</code> in
the directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S mount -F auid&gt;=1000 -F auid!=unset -F key=export</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S mount -F auid&gt;=1000 -F auid!=unset -F key=export</pre>
</td>
<td xml:lang="en-US">The unauthorized exportation of data to external media could result in an information leak
where classified information, Privacy Act information, and intellectual property could be lost. An audit
trail should be created each time a filesystem is mounted to help identify and guard against information
loss.</td>
<td></td>
</tr>
<tr>
<td>5.2.5</td>
<td>Record Events that Modify User/Group Information - /etc/shadow</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>
</td>
<td xml:lang="en-US">In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</td>
<td></td>
</tr>
<tr>
<td>5.2.5</td>
<td>Record Events that Modify User/Group Information - /etc/group</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>
</td>
<td xml:lang="en-US">In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</td>
<td></td>
</tr>
<tr>
<td>5.2.5</td>
<td>Record Events that Modify User/Group Information - /etc/security/opasswd</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>
</td>
<td xml:lang="en-US">In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</td>
<td></td>
</tr>
<tr>
<td>5.2.5</td>
<td>Record Events that Modify User/Group Information - /etc/gshadow</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file, in order to capture events that modify
account changes:
<br><br>
<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>
</td>
<td xml:lang="en-US">In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</td>
<td></td>
</tr>
<tr>
<td>5.2.14</td>
<td>Ensure auditd Collects File Deletion Events by User - unlinkat</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file deletion events
for all users and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
</td>
<td xml:lang="en-US">Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</td>
<td></td>
</tr>
<tr>
<td>5.2.14</td>
<td>Ensure auditd Collects File Deletion Events by User - unlink</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file deletion events
for all users and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
</td>
<td xml:lang="en-US">Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</td>
<td></td>
</tr>
<tr>
<td>5.2.14</td>
<td>Ensure auditd Collects File Deletion Events by User - rmdir</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file deletion events
for all users and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
</td>
<td xml:lang="en-US">Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</td>
<td></td>
</tr>
<tr>
<td>5.2.14</td>
<td>Ensure auditd Collects File Deletion Events by User - rename</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file deletion events
for all users and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
</td>
<td xml:lang="en-US">Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</td>
<td></td>
</tr>
<tr>
<td>5.2.14</td>
<td>Ensure auditd Collects File Deletion Events by User</td>
<td xml:lang="en-US">At a minimum the audit system should collect file deletion events
for all users and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir,unlink,unlinkat,rename,renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S rmdir,unlink,unlinkat,rename -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
</td>
<td xml:lang="en-US">Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</td>
<td></td>
</tr>
<tr>
<td>5.2.14</td>
<td>Ensure auditd Collects File Deletion Events by User - renameat</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file deletion events
for all users and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code>, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file, setting ARCH to either b32 or b64 as
appropriate for your system:
<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
</td>
<td xml:lang="en-US">Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</td>
<td></td>
</tr>
<tr>
<td>5.2.17</td>
<td>Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module</td>
<td xml:lang="en-US">If the <code>auditd</code> daemon is configured to use the <code>augenrules</code> program
to read audit rules during daemon startup (the default), add the following lines to a file
with suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code> to capture kernel module
loading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:
<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F key=modules</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility to read audit
rules during daemon startup, add the following lines to <code>/etc/audit/audit.rules</code> file
in order to capture kernel module loading and unloading events, setting ARCH to either b32 or
b64 as appropriate for your system:
<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F key=modules</pre>
</td>
<td xml:lang="en-US">The addition/removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</td>
<td></td>
</tr>
<tr>
<td>5.2.17</td>
<td>Ensure auditd Collects Information on Kernel Module Loading - init_module</td>
<td xml:lang="en-US">To capture kernel module loading events, use following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=<i>ARCH</i> -S init_module -F key=modules</pre>

Place to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured
to use the <code>augenrules</code> program (the default), add the line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,
add the line to file <code>/etc/audit/audit.rules</code>.</td>
<td xml:lang="en-US">The addition of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</td>
<td></td>
</tr>
<tr>
<td>5.2.17</td>
<td>Ensure auditd Collects Information on Kernel Module Unloading - delete_module</td>
<td xml:lang="en-US">To capture kernel module unloading events, use following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=<i>ARCH</i> -S delete_module -F key=modules</pre>

Place to add the line depends on a way <code>auditd</code> daemon is configured. If it is configured
to use the <code>augenrules</code> program (the default), add the line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,
add the line to file <code>/etc/audit/audit.rules</code>.</td>
<td xml:lang="en-US">The removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</td>
<td></td>
</tr>
<tr>
<td>5.2.17</td>
<td>Ensure auditd Collects Information on Kernel Module Loading and Unloading</td>
<td xml:lang="en-US">To capture kernel module loading and unloading events, use following lines, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>

-a always,exit -F arch=<i>ARCH</i> -S init_module,finit_module,delete_module -F key=modules

</pre>

The place to add the lines depends on a way <code>auditd</code> daemon is configured. If it is configured
to use the <code>augenrules</code> program (the default), add the lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code> utility,
add the lines to file <code>/etc/audit/audit.rules</code>.</td>
<td xml:lang="en-US">The addition/removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessul Delete Attempts to Files - renameat</td>
<td xml:lang="en-US">The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file.
<pre>-a always,exit -F arch=b32 -S renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Access Attempts to Files - openat</td>
<td xml:lang="en-US">At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Creation Attempts to Files - open O_CREAT</td>
<td xml:lang="en-US">The audit system should collect unauthorized file accesses for
all users and root. The <code>open</code> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will asure that unsuccessful attempts to create a
file via <code>open</code> syscall are collected.

If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the rules below to
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Access Attempts to Files - creat</td>
<td xml:lang="en-US">At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Creation Attempts to Files - open_by_handle_at O_CREAT</td>
<td xml:lang="en-US">The audit system should collect unauthorized file accesses for
all users and root. The <code>open_by_handle_at</code> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will asure that unsuccessful attempts to create a
file via <code>open_by_handle_at</code> syscall are collected.

If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the rules below to
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Modification Attempts to Files - open_by_handle_at O_TRUNC_WRITE</td>
<td xml:lang="en-US">The audit system should collect detailed unauthorized file accesses for
all users and root. The <code>open_by_handle_at</code> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.

The following auidt rules will asure that unsuccessful attempts to modify a
file via <code>open_by_handle_at</code> syscall are collected.

If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the rules below to
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Modification Attempts to Files - openat O_TRUNC_WRITE</td>
<td xml:lang="en-US">The audit system should collect detailed unauthorized file accesses for
all users and root. The <code>openat</code> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.

The following auidt rules will asure that unsuccessful attempts to modify a
file via <code>openat</code> syscall are collected.

If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the rules below to
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Access Attempts to Files - open_by_handle_at</td>
<td xml:lang="en-US">At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Ensure auditd Collects Unauthorized Access Attempts to Files (unsuccessful)</td>
<td xml:lang="en-US">At a minimum the audit system should collect unauthorized file
accesses for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Access Attempts to Files - ftruncate</td>
<td xml:lang="en-US">At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S ftruncate -F exiu=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Ensure auditd Unauthorized Access Attempts To open_by_handle_at Are Ordered Correctly</td>
<td xml:lang="en-US">The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <code>open_by_handle_at</code> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <code>open_by_handle_at</code> syscall are in the order shown below.
If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, check the order of rules below in
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
</td>
<td xml:lang="en-US">The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessul Delete Attempts to Files - unlinkat</td>
<td xml:lang="en-US">The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file.
<pre>-a always,exit -F arch=b32 -S unlinkat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlinkat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S unlinkat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlinkat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Creation Attempts to Files - openat O_CREAT</td>
<td xml:lang="en-US">The audit system should collect unauthorized file accesses for
all users and root. The <code>openat</code> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will asure that unsuccessful attempts to create a
file via <code>openat</code> syscall are collected.

If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the rules below to
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessul Delete Attempts to Files - rename</td>
<td xml:lang="en-US">The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file.
<pre>-a always,exit -F arch=b32 -S rename -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S rename -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S rename -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S rename -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Access Attempts to Files - truncate</td>
<td xml:lang="en-US">At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Access Attempts to Files - open</td>
<td xml:lang="en-US">At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessful Modification Attempts to Files - open O_TRUNC_WRITE</td>
<td xml:lang="en-US">The audit system should collect detailed unauthorized file accesses for
all users and root. The <code>open</code> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.
The following auidt rules will asure that unsuccessful attempts to modify a
file via <code>open</code> syscall are collected.
If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the rules below to
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Ensure auditd Rules For Unauthorized Attempts To open Are Ordered Correctly</td>
<td xml:lang="en-US">The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <code>open</code> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <code>open</code> syscall are in the order shown below.
If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, check the order of rules below in
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
</td>
<td xml:lang="en-US">The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Ensure auditd Rules For Unauthorized Attempts To openat Are Ordered Correctly</td>
<td xml:lang="en-US">The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <code>openat</code> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <code>openat</code> syscall are in the order shown below.
If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code>.
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, check the order of rules below in
<code>/etc/audit/audit.rules</code> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
</td>
<td xml:lang="en-US">The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Unsuccessul Delete Attempts to Files - unlink</td>
<td xml:lang="en-US">The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>.

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file.
<pre>-a always,exit -F arch=b32 -S unlink -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlink -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S unlink -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
</td>
<td xml:lang="en-US">Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Ensure auditd Collects Information on the Use of Privileged Commands</td>
<td xml:lang="en-US">At a minimum, the audit system should collect the execution of
privileged commands for all users and root. To find the relevant setuid /
setgid programs, run the following command for each local partition
<i>PART</i>:
<pre>$ sudo find <i>PART</i> -xdev -type f -perm -4000 -o -type f -perm -2000 2&gt;/dev/null</pre>
If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add a line of
the following form to a file with suffix <code>.rules</code> in the directory
<code>/etc/audit/rules.d</code> for each setuid / setgid program on the system,
replacing the <i>SETUID_PROG_PATH</i> part with the full path of that setuid /
setgid program in the list:
<pre>-a always,exit -F path=<i>SETUID_PROG_PATH</i> -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add a line of the following
form to <code>/etc/audit/audit.rules</code> for each setuid / setgid program on the
system, replacing the <i>SETUID_PROG_PATH</i> part with the full path of that
setuid / setgid program in the list:
<pre>-a always,exit -F path=<i>SETUID_PROG_PATH</i> -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>
</td>
<td xml:lang="en-US">Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br><br>
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - chmod</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured to
use the <code>augenrules</code> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <code>.rules</code> in
the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - fsetxattr</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - lremovexattr</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root.
<br><br>
If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - lsetxattr</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - lchown</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - fremovexattr</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root.
<br><br>
If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - setxattr</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - chown</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured to
use the <code>augenrules</code> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <code>.rules</code> in
the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - removexattr</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root.
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>augenrules</code>
program to read audit rules during daemon startup (the default), add the
following line to a file with suffix <code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<br><br>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - fchmod</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured to
use the <code>augenrules</code> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <code>.rules</code> in
the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - fchmodat</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured to
use the <code>augenrules</code> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <code>.rules</code> in
the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - fchown</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Record Events that Modify the System's Discretionary Access Controls - fchownat</td>
<td xml:lang="en-US">At a minimum, the audit system should collect file permission
changes for all users and root. If the <code>auditd</code> daemon is configured
to use the <code>augenrules</code> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<code>.rules</code> in the directory <code>/etc/audit/rules.d</code>:
<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following line to
<code>/etc/audit/audit.rules</code> file:
<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
</td>
<td xml:lang="en-US">The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</td>
<td></td>
</tr>
<tr>
<td>4.1.8</td>
<td>Record Attempts to Alter Logon and Logout Events - lastlog</td>
<td xml:lang="en-US">The audit system already collects login information for all users
and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code> in order to watch for attempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/lastlog -p wa -k logins</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file in order to watch for unattempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/lastlog -p wa -k logins</pre>
</td>
<td xml:lang="en-US">Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</td>
<td></td>
</tr>
<tr>
<td>4.1.8</td>
<td>Record Attempts to Alter Logon and Logout Events - faillock</td>
<td xml:lang="en-US">The audit system already collects login information for all users
and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code> in order to watch for attempted manual
edits of files involved in storing logon events:
<pre>-w /var/run/faillock -p wa -k logins</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file in order to watch for unattempted manual
edits of files involved in storing logon events:
<pre>-w /var/run/faillock -p wa -k logins</pre>
</td>
<td xml:lang="en-US">Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</td>
<td></td>
</tr>
<tr>
<td>5.2.8</td>
<td>Record Attempts to Alter Logon and Logout Events - tallylog</td>
<td xml:lang="en-US">The audit system already collects login information for all users
and root. If the <code>auditd</code> daemon is configured to use the
<code>augenrules</code> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <code>.rules</code> in the
directory <code>/etc/audit/rules.d</code> in order to watch for attempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/tallylog -p wa -k logins</pre>
If the <code>auditd</code> daemon is configured to use the <code>auditctl</code>
utility to read audit rules during daemon startup, add the following lines to
<code>/etc/audit/audit.rules</code> file in order to watch for unattempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/tallylog -p wa -k logins</pre>
</td>
<td xml:lang="en-US">Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</td>
<td></td>
</tr>
<tr>
<td>1.5.4</td>
<td>Disable Prelinking</td>
<td xml:lang="en-US">The prelinking feature changes binaries in an attempt to decrease their startup
time. In order to disable it, change or add the following line inside the file
<code>/etc/sysconfig/prelink</code>:
<pre>PRELINKING=no</pre>
Next, run the following command to return binaries to a normal, non-prelinked state:
<pre>$ sudo /usr/sbin/prelink -ua</pre>
</td>
<td xml:lang="en-US">Because the prelinking feature changes binaries, it can interfere with the
operation of certain software and/or modes such as AIDE, FIPS, etc.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.4</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.5</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.6</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.1</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.2</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.3</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.4</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.5</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.6</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.7</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.8</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.9</td>
<td>Verify and Correct Ownership with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file ownership
permissions of installed software packages, including many that are
important to system security. After locating a file with incorrect
permissions, which can be found with
<pre>rpm -Va | awk '{ if (substr($0,6,1)=="U" || substr($0,7,1)=="G") print $NF }'</pre>
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setugids <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Ownership of binaries and configuration files that is incorrect
could allow an unauthorized user to gain privileges that they should
not have. The ownership set by the vendor should be maintained. Any
deviations from this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.4</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.5</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.6</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.1</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.2</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.3</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.4</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.5</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.6</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.7</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.8</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>6.1.9</td>
<td>Verify and Correct File Permissions with RPM</td>
<td xml:lang="en-US">The RPM package management system can check file access permissions
of installed software packages, including many that are important
to system security.
Verify that the file permissions of system files
and commands match vendor values. Check the file permissions
with the following command:
<pre>$ sudo rpm -Va | awk '{ if (substr($0,2,1)=="M") print $NF }'</pre>
Output indicates files that do not match vendor defaults.
After locating a file with incorrect permissions,
run the following command to determine which package owns it:
<pre>$ rpm -qf <i>FILENAME</i></pre>
<br>
Next, run the following command to reset its permissions to
the correct values:
<pre>$ sudo rpm --setperms <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">Permissions on system binaries and configuration files that are too generous
could allow an unauthorized user to gain privileges that they should not have.
The permissions set by the vendor should be maintained. Any deviations from
this baseline should be investigated.</td>
<td></td>
</tr>
<tr>
<td>1.2.6</td>
<td>Verify File Hashes with RPM</td>
<td xml:lang="en-US">Without cryptographic integrity protections, system
executables and files can be altered by unauthorized users without
detection.
The RPM package management system can check the hashes of
installed software packages, including many that are important to system
security.
To verify that the cryptographic hash of system files and commands matches vendor
values, run the following command to list which files on the system
have hashes that differ from what is expected by the RPM database:
<pre>$ rpm -Va --noconfig | grep '^..5'</pre>
A "c" in the second column indicates that a file is a configuration file, which
may appropriately be expected to change. If the file was not expected to
change, investigate the cause of the change using audit logs or other means.
The package can then be reinstalled to restore the file.
Run the following command to determine which package owns the file:
<pre>$ rpm -qf <i>FILENAME</i></pre>
The package can be reinstalled from a yum repository using the command:
<pre>$ sudo yum reinstall <i>PACKAGENAME</i></pre>
Alternatively, the package can be reinstalled from trusted media using the command:
<pre>$ sudo rpm -Uvh <i>PACKAGENAME</i></pre>
</td>
<td xml:lang="en-US">The hashes of important files like system executables should match the
information given by the RPM database. Executables with erroneous hashes could
be a sign of nefarious activity on the system.</td>
<td></td>
</tr>
<tr>
<td>1.4.2</td>
<td>Set the UEFI Boot Loader Admin Username to a Non-Default Value</td>
<td xml:lang="en-US">The grub2 boot loader should have a superuser account and password
protection enabled to protect boot-time settings.
<br><br>
To maximize the protection, select a password-protected superuser account with unique name, and modify the
<code>/etc/grub.d/01_users</code> configuration file to reflect the account name change.
<br><br>
It is highly suggested not to use common administrator account names like root,
admin, or administrator for the grub2 superuser account.
<br><br>
Change the superuser to a different username (The default is 'root').
<pre>$ sed -i 's/\(set superuser=\).*/\1"&lt;unique user ID&gt;"/g' /etc/grub.d/01_users</pre>
<br><br>
Once the superuser account has been added,
update the
<code>grub.cfg</code> file by running:
<pre>grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg</pre>
</td>
<td xml:lang="en-US">Having a non-default grub superuser username makes password-guessing attacks less effective.

For more information on how to configure the grub2 superuser account and password,
please refer to
<ul>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-working_with_the_grub_2_boot_loader#sec-Protecting_GRUB_2_with_a_Password">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-working_with_the_grub_2_boot_loader#sec-Protecting_GRUB_2_with_a_Password</a></li>.
</ul>
</td>
<td></td>
</tr>
<tr>
<td>1.4.1</td>
<td>Verify the UEFI Boot Loader grub.cfg Permissions</td>
<td xml:lang="en-US">File permissions for <code>/boot/efi/EFI/redhat/grub.cfg</code> should be set to 700.

To properly set the permissions of <code>/boot/efi/EFI/redhat/grub.cfg</code>, run the command:
<pre>$ sudo chmod 700 /boot/efi/EFI/redhat/grub.cfg</pre>
</td>
<td xml:lang="en-US">Proper permissions ensure that only the root user can modify important boot
parameters.</td>
<td></td>
</tr>
<tr>
<td>1.4.2</td>
<td>Set the Boot Loader Admin Username to a Non-Default Value</td>
<td xml:lang="en-US">The grub2 boot loader should have a superuser account and password
protection enabled to protect boot-time settings.
<br><br>
To maximize the protection, select a password-protected superuser account with unique name, and modify the
<code>/etc/grub.d/01_users</code> configuration file to reflect the account name change.
<br><br>
Do not to use common administrator account names like root,
admin, or administrator for the grub2 superuser account.
<br><br>
Change the superuser to a different username (The default is 'root').
<pre>$ sed -i 's/\(set superuser=\).*/\1"&lt;unique user ID&gt;"/g' /etc/grub.d/01_users</pre>
<br><br>
Once the superuser account has been added,
update the
<code>grub.cfg</code> file by running:
<pre>grub2-mkconfig -o /boot/grub2/grub.cfg</pre>
</td>
<td xml:lang="en-US">Having a non-default grub superuser username makes password-guessing attacks less effective.</td>
<td></td>
</tr>
<tr>
<td>1.4.1</td>
<td>Verify the UEFI Boot Loader grub.cfg Group Ownership</td>
<td xml:lang="en-US">The file <code>/boot/efi/EFI/redhat/grub.cfg</code> should
be group-owned by the <code>root</code> group to prevent
destruction or modification of the file.

To properly set the group owner of <code>/boot/efi/EFI/redhat/grub.cfg</code>, run the command:
<pre>$ sudo chgrp root /boot/efi/EFI/redhat/grub.cfg</pre>
</td>
<td xml:lang="en-US">The <code>root</code> group is a highly-privileged group. Furthermore, the group-owner of this
file should not have any access privileges anyway.</td>
<td></td>
</tr>
<tr>
<td>1.4.2</td>
<td>Set the UEFI Boot Loader Password</td>
<td xml:lang="en-US">The grub2 boot loader should have a superuser account and password
protection enabled to protect boot-time settings.
<br><br>
Since plaintext passwords are a security risk, generate a hash for the password
by running the following command:
<pre>$ grub2-setpassword</pre>
When prompted, enter the password that was selected.
<br><br>
Once the superuser password has been added,
update the
<code>grub.cfg</code> file by running:
<pre>grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg</pre>
</td>
<td xml:lang="en-US">Password protection on the boot loader configuration ensures
users with physical access cannot trivially alter
important bootloader settings. These include which kernel to use,
and whether to enter single-user mode.</td>
<td></td>
</tr>
<tr>
<td>1.4.1</td>
<td>Verify the UEFI Boot Loader grub.cfg User Ownership</td>
<td xml:lang="en-US">The file <code>/boot/efi/EFI/redhat/grub.cfg</code> should
be owned by the <code>root</code> user to prevent destruction
or modification of the file.

To properly set the owner of <code>/boot/efi/EFI/redhat/grub.cfg</code>, run the command:
<pre>$ sudo chown root /boot/efi/EFI/redhat/grub.cfg </pre>
</td>
<td xml:lang="en-US">Only root should be able to modify important boot parameters.</td>
<td></td>
</tr>
<tr>
<td>1.6.2</td>
<td>Install libselinux Package</td>
<td xml:lang="en-US">The <code>libselinux</code> package can be installed with the following command:
<pre>
$ sudo yum install libselinux</pre>
</td>
<td xml:lang="en-US">Security-enhanced Linux is a feature of the Linux kernel and a number of utilities
with enhanced security functionality designed to add mandatory access controls to Linux.

The <code>libselinux</code> package contains the core library of the Security-enhanced Linux system.</td>
<td></td>
</tr>
<tr>
<td>1.6.1.5</td>
<td>Uninstall mcstrans Package</td>
<td xml:lang="en-US">The <code>mcstransd</code> daemon provides category label information
to client processes requesting information. The label translations are defined
in <code>/etc/selinux/targeted/setrans.conf</code>.
The <code>mcstrans</code> package can be removed with the following command:
<pre>
$ sudo yum erase mcstrans</pre>
</td>
<td xml:lang="en-US">Since this service is not used very often, disable it to reduce the
amount of potentially vulnerable code running on the system.

NOTE: This rule was added in support of the CIS RHEL6 v1.2.0 benchmark. Please
note that Red Hat does not feel this rule is security relevant.</td>
<td></td>
</tr>
<tr>
<td>1.7.1.5</td>
<td>Ensure No Daemons are Unconfined by SELinux</td>
<td xml:lang="en-US">Daemons for which the SELinux policy does not contain rules will inherit the
context of the parent process. Because daemons are launched during
startup and descend from the <code>init</code> process, they inherit the <code>initrc_t</code> context.
<br>
<br>
To check for unconfined daemons, run the following command:
<pre>$ sudo ps -eZ | egrep "initrc" | egrep -vw "tr|ps|egrep|bash|awk" | tr ':' ' ' | awk '{ print $NF }'</pre>
It should produce no output in a well-configured system.</td>
<td xml:lang="en-US">Daemons which run with the <code>initrc_t</code> context may cause AVC denials,
or allow privileges that the daemon does not require.</td>
<td></td>
</tr>
<tr>
<td>1.1.1.2</td>
<td>Disable Mounting of freevxfs</td>
<td xml:lang="en-US">
To configure the system to prevent the <code>freevxfs</code>
kernel module from being loaded, add the following line to a file in the directory <code>/etc/modprobe.d</code>:
<pre>install freevxfs /bin/true</pre>
This effectively prevents usage of this uncommon filesystem.</td>
<td xml:lang="en-US">Linux kernel modules which implement filesystems that are not needed by the
local system should be disabled.</td>
<td></td>
</tr>
<tr>
<td>1.1.1.5</td>
<td>Disable Mounting of hfsplus</td>
<td xml:lang="en-US">
To configure the system to prevent the <code>hfsplus</code>
kernel module from being loaded, add the following line to a file in the directory <code>/etc/modprobe.d</code>:
<pre>install hfsplus /bin/true</pre>
This effectively prevents usage of this uncommon filesystem.</td>
<td xml:lang="en-US">Linux kernel modules which implement filesystems that are not needed by the
local system should be disabled.</td>
<td></td>
</tr>
<tr>
<td>1.1.1.3</td>
<td>Disable Mounting of jffs2</td>
<td xml:lang="en-US">
To configure the system to prevent the <code>jffs2</code>
kernel module from being loaded, add the following line to a file in the directory <code>/etc/modprobe.d</code>:
<pre>install jffs2 /bin/true</pre>
This effectively prevents usage of this uncommon filesystem.</td>
<td xml:lang="en-US">Linux kernel modules which implement filesystems that are not needed by the
local system should be disabled.</td>
<td></td>
</tr>
<tr>
<td>1.1.1.4</td>
<td>Disable Mounting of hfs</td>
<td xml:lang="en-US">
To configure the system to prevent the <code>hfs</code>
kernel module from being loaded, add the following line to a file in the directory <code>/etc/modprobe.d</code>:
<pre>install hfs /bin/true</pre>
This effectively prevents usage of this uncommon filesystem.</td>
<td xml:lang="en-US">Linux kernel modules which implement filesystems that are not needed by the
local system should be disabled.</td>
<td></td>
</tr>
<tr>
<td>1.1.3</td>
<td>Add nosuid Option to /home</td>
<td xml:lang="en-US">The <code>nosuid</code> mount option can be used to prevent
execution of setuid programs in <code>/home</code>. The SUID and SGID permissions
should not be required in these user data directories.
Add the <code>nosuid</code> option to the fourth column of
<code>/etc/fstab</code> for the line which controls mounting of
<code>/home</code>.</td>
<td xml:lang="en-US">The presence of SUID and SGID executables should be tightly controlled. Users
should not be able to execute SUID or SGID binaries from user home directory partitions.</td>
<td></td>
</tr>
<tr>
<td>1.1.11</td>
<td>Add nodev Option to Non-Root Local Partitions</td>
<td xml:lang="en-US">The <code>nodev</code> mount option prevents files from being interpreted as
character or block devices. Legitimate character and block devices should
exist only in the <code>/dev</code> directory on the root partition or within
chroot jails built for system services.
Add the <code>nodev</code> option to the fourth column of
<code>/etc/fstab</code> for the line which controls mounting of

    any non-root local partitions.</td>
<td xml:lang="en-US">The <code>nodev</code> mount option prevents files from being
interpreted as character or block devices. The only legitimate location
for device files is the <code>/dev</code> directory located on the root partition.
The only exception to this is chroot jails, for which it is not advised
to set <code>nodev</code> on these filesystems.</td>
<td></td>
</tr>
<tr>
<td>1.1.6</td>
<td>Bind Mount /var/tmp To /tmp</td>
<td xml:lang="en-US">The <code>/var/tmp</code> directory is a world-writable directory. Bind-mount
it to <code>/tmp</code> in order to consolidate temporary storage into one
location protected by the same techniques as <code>/tmp</code>. To do so, edit
<code>/etc/fstab</code> and add the following line:
<pre>/tmp     /var/tmp     none     rw,nodev,noexec,nosuid,bind     0 0</pre>
See the <code>mount(8)</code> man page for further explanation of bind mounting.</td>
<td xml:lang="en-US">Having multiple locations for temporary storage is not required. Unless absolutely
necessary to meet requirements, the storage location <code>/var/tmp</code> should be bind mounted to
<code>/tmp</code> and thus share the same protections.</td>
<td></td>
</tr>
<tr>
<td>1.5.2</td>
<td>Enable ExecShield via sysctl</td>
<td xml:lang="en-US">By default on Red Hat Enterprise Linux 7 64-bit systems, ExecShield is
enabled and can only be disabled if the hardware does not support
ExecShield or is disabled in <code>/etc/default/grub</code>. For Red Hat
Enterprise Linux 7 32-bit systems, <code>sysctl</code> can be used to enable
ExecShield.</td>
<td xml:lang="en-US">ExecShield uses the segmentation feature on all x86 systems to prevent
execution in memory higher than a certain address. It writes an address as
a limit in the code segment descriptor, to control where code can be
executed, on a per-process basis. When the kernel places a process's memory
regions such as the stack and heap higher than this address, the hardware
prevents execution in that address range. This is enabled by default on the
latest Red Hat and Fedora systems if supported by the hardware.</td>
<td></td>
</tr>
<tr>
<td>1.6.1</td>
<td>Enable Kernel Parameter to Enforce DAC on Symlinks</td>
<td xml:lang="en-US">To set the runtime status of the <code>fs.protected_symlinks</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w fs.protected_symlinks=1</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>fs.protected_symlinks = 1</pre>
</td>
<td xml:lang="en-US">By enabling this kernel parameter, symbolic links are permitted to be followed
only when outside a sticky world-writable directory, or when the UID of the
link and follower match, or when the directory owner matches the symlink's owner.
Disallowing such symlinks helps mitigate vulnerabilities based on insecure file system
accessed by privileged programs, avoiding an exploitation vector exploiting unsafe use of
<code>open()</code> or <code>creat()</code>.</td>
<td></td>
</tr>
<tr>
<td>6.1.10</td>
<td>Ensure No World-Writable Files Exist</td>
<td xml:lang="en-US">It is generally a good idea to remove global (other) write
access to a file when it is discovered. However, check with
documentation for specific applications before making changes.
Also, monitor for recurring world-writable files, as these may be
symptoms of a misconfigured application or user account. Finally,
this applies to real files and not virtual files that are a part of
pseudo file systems such as <code>sysfs</code> or <code>procfs</code>.</td>
<td xml:lang="en-US">Data in world-writable files can be modified by any
user on the system. In almost all circumstances, files can be
configured using a combination of user and group permissions to
support whatever legitimate access is needed without the risk
caused by world-writable files.</td>
<td></td>
</tr>
<tr>
<td>6.1.13</td>
<td>Ensure All SUID Executables Are Authorized</td>
<td xml:lang="en-US">The SUID (set user id) bit should be set only on files that were
installed via authorized means. A straightforward means of identifying
unauthorized SUID files is determine if any were not installed as part of an
RPM package, which is cryptographically verified. Investigate the origin
of any unpackaged SUID files.
This configuration check considers authorized SUID files which were installed via RPM.
It is assumed that when an individual has sudo access to install an RPM
and all packages are signed with an organizationally-recognized GPG key,
the software should be considered an approved package on the system.
Any SUID file not deployed through an RPM will be flagged for further review.</td>
<td xml:lang="en-US">Executable files with the SUID permission run with the privileges of
the owner of the file. SUID files of uncertain provenance could allow for
unprivileged users to elevate privileges. The presence of these files should be
strictly controlled on the system.</td>
<td></td>
</tr>
<tr>
<td>6.1.11</td>
<td>Ensure All Files Are Owned by a User</td>
<td xml:lang="en-US">If any files are not owned by a user, then the
cause of their lack of ownership should be investigated.
Following this, the files should be deleted or assigned to an
appropriate user.</td>
<td xml:lang="en-US">Unowned files do not directly imply a security problem, but they are generally
a sign that something is amiss. They may
be caused by an intruder, by incorrect software installation or
draft software removal, or by failure to remove all files belonging
to a deleted account. The files should be repaired so they
will not cause problems when accounts are created in the future,
and the cause should be discovered and addressed.</td>
<td></td>
</tr>
<tr>
<td>6.1.14</td>
<td>Ensure All SGID Executables Are Authorized</td>
<td xml:lang="en-US">The SGID (set group id) bit should be set only on files that were
installed via authorized means. A straightforward means of identifying
unauthorized SGID files is determine if any were not installed as part of an
RPM package, which is cryptographically verified. Investigate the origin
of any unpackaged SGID files.
This configuration check considers authorized SGID files which were installed via RPM.
It is assumed that when an individual has sudo access to install an RPM
and all packages are signed with an organizationally-recognized GPG key,
the software should be considered an approved package on the system.
Any SGID file not deployed through an RPM will be flagged for further review.</td>
<td xml:lang="en-US">Executable files with the SGID permission run with the privileges of
the owner of the file. SGID files of uncertain provenance could allow for
unprivileged users to elevate privileges. The presence of these files should be
strictly controlled on the system.</td>
<td></td>
</tr>
<tr>
<td>6.1.12</td>
<td>Ensure All Files Are Owned by a Group</td>
<td xml:lang="en-US">If any files are not owned by a group, then the
cause of their lack of group-ownership should be investigated.
Following this, the files should be deleted or assigned to an
appropriate group.</td>
<td xml:lang="en-US">Unowned files do not directly imply a security problem, but they are generally
a sign that something is amiss. They may
be caused by an intruder, by incorrect software installation or
draft software removal, or by failure to remove all files belonging
to a deleted account. The files should be repaired so they
will not cause problems when accounts are created in the future,
and the cause should be discovered and addressed.</td>
<td></td>
</tr>
<tr>
<td>1.6.1</td>
<td>Enable Kernel Parameter to Enforce DAC on Hardlinks</td>
<td xml:lang="en-US">To set the runtime status of the <code>fs.protected_hardlinks</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w fs.protected_hardlinks=1</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>fs.protected_hardlinks = 1</pre>
</td>
<td xml:lang="en-US">By enabling this kernel parameter, users can no longer create soft or hard links to
files which they do not own. Disallowing such hardlinks mitigate vulnerabilities
based on insecure file system accessed by privileged programs, avoiding an
exploitation vector exploiting unsafe use of <code>open()</code> or <code>creat()</code>.</td>
<td></td>
</tr>
<tr>
<td>6.1.9</td>
<td>Verify Permissions on Backup gshadow File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/gshadow-</code>, run the command:
<pre>$ sudo chmod 0000 /etc/gshadow-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/gshadow-</code> file is a backup of <code>/etc/gshadow</code>, and as such,
it contains group password hashes. Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.3</td>
<td>Verify Permissions on shadow File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/shadow</code>, run the command:
<pre>$ sudo chmod 0000 /etc/shadow</pre>
</td>
<td xml:lang="en-US">The <code>/etc/shadow</code> file contains the list of local
system accounts and stores password hashes. Protection of this file is
critical for system security. Failure to give ownership of this file
to root provides the designated owner with access to sensitive information
which could weaken the system security posture.</td>
<td></td>
</tr>
<tr>
<td>6.1.5</td>
<td>Verify Group Who Owns gshadow File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/gshadow</code>, run the command: <pre>$ sudo chgrp root /etc/gshadow</pre>
</td>
<td xml:lang="en-US">The <code>/etc/gshadow</code> file contains group password hashes. Protection of this file
is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.2</td>
<td>Verify User Who Owns passwd File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/passwd</code>, run the command: <pre>$ sudo chown root /etc/passwd </pre>
</td>
<td xml:lang="en-US">The <code>/etc/passwd</code> file contains information about the users that are configured on
the system. Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.3</td>
<td>Verify Group Who Owns shadow File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/shadow</code>, run the command: <pre>$ sudo chgrp root /etc/shadow</pre>
</td>
<td xml:lang="en-US">The <code>/etc/shadow</code> file stores password hashes. Protection of this file is
critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.6</td>
<td>Verify Group Who Owns Backup passwd File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/passwd-</code>, run the command: <pre>$ sudo chgrp root /etc/passwd-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/passwd-</code> file is a backup file of <code>/etc/passwd</code>, and as such,
it contains information about the users that are configured on the system.
Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.8</td>
<td>Verify Permissions on Backup group File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/group-</code>, run the command:
<pre>$ sudo chmod 0644 /etc/group-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/group-</code> file is a backup file of <code>/etc/group</code>, and as such,
it contains information regarding groups that are configured on the system.
Protection of this file is important for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.5</td>
<td>Verify Permissions on gshadow File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/gshadow</code>, run the command:
<pre>$ sudo chmod 0000 /etc/gshadow</pre>
</td>
<td xml:lang="en-US">The <code>/etc/gshadow</code> file contains group password hashes. Protection of this file
is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.5</td>
<td>Verify User Who Owns gshadow File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/gshadow</code>, run the command: <pre>$ sudo chown root /etc/gshadow </pre>
</td>
<td xml:lang="en-US">The <code>/etc/gshadow</code> file contains group password hashes. Protection of this file
is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.3</td>
<td>Verify User Who Owns shadow File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/shadow</code>, run the command: <pre>$ sudo chown root /etc/shadow </pre>
</td>
<td xml:lang="en-US">The <code>/etc/shadow</code> file contains the list of local
system accounts and stores password hashes. Protection of this file is
critical for system security. Failure to give ownership of this file
to root provides the designated owner with access to sensitive information
which could weaken the system security posture.</td>
<td></td>
</tr>
<tr>
<td>6.1.4</td>
<td>Verify Permissions on group File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/passwd</code>, run the command:
<pre>$ sudo chmod 0644 /etc/passwd</pre>
</td>
<td xml:lang="en-US">The <code>/etc/group</code> file contains information regarding groups that are configured
on the system. Protection of this file is important for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.6</td>
<td>Verify User Who Owns Backup passwd File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/passwd-</code>, run the command: <pre>$ sudo chown root /etc/passwd- </pre>
</td>
<td xml:lang="en-US">The <code>/etc/passwd-</code> file is a backup file of <code>/etc/passwd</code>, and as such,
it contains information about the users that are configured on the system.
Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.2</td>
<td>Verify Group Who Owns passwd File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/passwd</code>, run the command: <pre>$ sudo chgrp root /etc/passwd</pre>
</td>
<td xml:lang="en-US">The <code>/etc/passwd</code> file contains information about the users that are configured on
the system. Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.6</td>
<td>Verify Permissions on Backup passwd File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/passwd-</code>, run the command:
<pre>$ sudo chmod 0644 /etc/passwd-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/passwd-</code> file is a backup file of <code>/etc/passwd</code>, and as such,
it contains information about the users that are configured on the system.
Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.8</td>
<td>Verify User Who Owns Backup group File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/group-</code>, run the command: <pre>$ sudo chown root /etc/group- </pre>
</td>
<td xml:lang="en-US">The <code>/etc/group-</code> file is a backup file of <code>/etc/group</code>, and as such,
it contains information regarding groups that are configured on the system.
Protection of this file is important for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.9</td>
<td>Verify Group Who Owns Backup gshadow File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/gshadow-</code>, run the command: <pre>$ sudo chgrp root /etc/gshadow-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/gshadow-</code> file is a backup of <code>/etc/gshadow</code>, and as such,
it contains group password hashes. Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.4</td>
<td>Verify Group Who Owns group File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/group</code>, run the command: <pre>$ sudo chgrp root /etc/group</pre>
</td>
<td xml:lang="en-US">The <code>/etc/group</code> file contains information regarding groups that are configured
on the system. Protection of this file is important for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.8</td>
<td>Verify Group Who Owns Backup group File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/group-</code>, run the command: <pre>$ sudo chgrp root /etc/group-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/group-</code> file is a backup file of <code>/etc/group</code>, and as such,
it contains information regarding groups that are configured on the system.
Protection of this file is important for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.7</td>
<td>Verify User Who Owns Backup shadow File</td>
<td xml:lang="en-US"> To properly set the group owner of <code>/etc/shadow-</code>, run the command: <pre>$ sudo chgrp root /etc/shadow-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/shadow-</code> file is a backup file of <code>/etc/shadow</code>, and as such,
it contains the list of local system accounts and password hashes.
Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.7</td>
<td>Verify Group Who Owns Backup shadow File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/shadow-</code>, run the command: <pre>$ sudo chown root /etc/shadow- </pre>
</td>
<td xml:lang="en-US">The <code>/etc/shadow-</code> file is a backup file of <code>/etc/shadow</code>, and as such,
it contains the list of local system accounts and password hashes.
Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.7</td>
<td>Verify Permissions on Backup shadow File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/shadow-</code>, run the command:
<pre>$ sudo chmod 0000 /etc/shadow-</pre>
</td>
<td xml:lang="en-US">The <code>/etc/shadow-</code> file is a backup file of <code>/etc/shadow</code>, and as such,
it contains the list of local system accounts and password hashes.
Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.2</td>
<td>Verify Permissions on passwd File</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/passwd</code>, run the command:
<pre>$ sudo chmod 0644 /etc/passwd</pre>
</td>
<td xml:lang="en-US">If the <code>/etc/passwd</code> file is writable by a group-owner or the
world the risk of its compromise is increased. The file contains the list of
accounts on the system and associated information, and protection of this file
is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.4</td>
<td>Verify User Who Owns group File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/group</code>, run the command: <pre>$ sudo chown root /etc/group </pre>
</td>
<td xml:lang="en-US">The <code>/etc/group</code> file contains information regarding groups that are configured
on the system. Protection of this file is important for system security.</td>
<td></td>
</tr>
<tr>
<td>6.1.9</td>
<td>Verify User Who Owns Backup gshadow File</td>
<td xml:lang="en-US"> To properly set the owner of <code>/etc/gshadow-</code>, run the command: <pre>$ sudo chown root /etc/gshadow- </pre>
</td>
<td xml:lang="en-US">The <code>/etc/gshadow-</code> file is a backup of <code>/etc/gshadow</code>, and as such,
it contains group password hashes. Protection of this file is critical for system security.</td>
<td></td>
</tr>
<tr>
<td>5.1.1</td>
<td>Ensure syslog-ng is Installed</td>
<td xml:lang="en-US">syslog-ng can be installed in replacement of rsyslog.
The <code>syslog-ng-core</code> package can be installed with the following command:
<pre>
$ sudo yum install syslog-ng-core</pre>
</td>
<td xml:lang="en-US">The syslog-ng-core package provides the syslog-ng daemon, which provides
system logging services.</td>
<td></td>
</tr>
<tr>
<td>5.1.2</td>
<td>Enable syslog-ng Service</td>
<td xml:lang="en-US">The <code>syslog-ng</code> service (in replacement of rsyslog) provides syslog-style logging by default on Debian 8.

The <code>syslog-ng</code> service can be enabled with the following command:
<pre>$ sudo systemctl enable syslog-ng.service</pre>
</td>
<td xml:lang="en-US">The <code>syslog-ng</code> service must be running in order to provide
logging services, which are essential to system administration.</td>
<td></td>
</tr>
<tr>
<td>4.2.1.5</td>
<td>Enable rsyslog to Accept Messages via TCP, if Acting As Log Server</td>
<td xml:lang="en-US">The <code>rsyslog</code> daemon should not accept remote messages
unless the system acts as a log server.
If the system needs to act as a central log server, add the following lines to
<code>/etc/rsyslog.conf</code> to enable reception of messages over TCP:
<pre>$ModLoad imtcp
$InputTCPServerRun 514</pre>
</td>
<td xml:lang="en-US">If the system needs to act as a log server, this ensures that it can receive
messages over a reliable TCP connection.</td>
<td></td>
</tr>
<tr>
<td>4.2.1.5</td>
<td>Enable rsyslog to Accept Messages via UDP, if Acting As Log Server</td>
<td xml:lang="en-US">The <code>rsyslog</code> daemon should not accept remote messages
unless the system acts as a log server.
If the system needs to act as a central log server, add the following lines to
<code>/etc/rsyslog.conf</code> to enable reception of messages over UDP:
<pre>$ModLoad imudp
$UDPServerRun 514</pre>
</td>
<td xml:lang="en-US">Many devices, such as switches, routers, and other Unix-like systems, may only support
the traditional syslog transmission over UDP. If the system must act as a log server,
this enables it to receive their messages as well.</td>
<td></td>
</tr>
<tr>
<td>3.7</td>
<td>Deactivate Wireless Network Interfaces</td>
<td xml:lang="en-US">Deactivating wireless network interfaces should prevent
normal usage of the wireless capability.
<br><br>
Configure the system to disable all wireless network interfaces with the
following command:
<pre>$ sudo nmcli radio wifi off</pre>
</td>
<td xml:lang="en-US">The use of wireless networking can introduce many different attack vectors into
the organization's network. Common attack vectors such as malicious association
and ad hoc networks will allow an attacker to spoof a wireless access point
(AP), allowing validated systems to connect to the malicious AP and enabling the
attacker to monitor and record network traffic. These malicious APs can also
serve to create a man-in-the-middle attack or be used to create a denial of
service to valid network resources.</td>
<td></td>
</tr>
<tr>
<td>3.3.3</td>
<td>Disable IPv6 Networking Support Automatic Loading</td>
<td xml:lang="en-US">To disable support for (<code>ipv6</code>) add the following line to
<code>/etc/sysctl.d/ipv6.conf</code> (or another file in
<code>/etc/sysctl.d</code>):
<pre>net.ipv6.conf.all.disable_ipv6 = 1</pre>
This disables IPv6 on all network interfaces as other services and system
functionality require the IPv6 stack loaded to work.</td>
<td xml:lang="en-US">Any unnecessary network stacks - including IPv6 - should be disabled, to reduce
the vulnerability to exploitation.</td>
<td></td>
</tr>
<tr>
<td>3.3.3</td>
<td>Ensure IPv6 is disabled through kernel boot parameter</td>
<td xml:lang="en-US">To disable IPv6 protocol support in the Linux kernel,
add the argument <code>ipv6.disable=1</code> to the default
GRUB2 command line for the Linux operating system in

<code>/etc/default/grub</code>, so that the line looks similar to
<pre>GRUB_CMDLINE_LINUX="... ipv6.disable=1 ..."</pre>
In case the <code>GRUB_DISABLE_RECOVERY</code> is set to true, then the parameter should be added to the <code>GRUB_CMDLINE_LINUX_DEFAULT</code> instead.
Run one of following command to ensure that the configuration is applied when booting currently installed kernels:
<pre>sudo grub2-mkconfig -o /boot/grub2/grub.cfg</pre>
or
<pre>sudo /sbin/grubby --update-kernel=ALL --args="ipv6.disable=1"</pre>
</td>
<td xml:lang="en-US">Any unnecessary network stacks, including IPv6, should be disabled to reduce
the vulnerability to exploitation.</td>
<td></td>
</tr>
<tr>
<td>3.3.2</td>
<td>Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv6 Interfaces</td>
<td xml:lang="en-US">To set the runtime status of the <code>net.ipv6.conf.default.accept_redirects</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w net.ipv6.conf.default.accept_redirects=0</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>net.ipv6.conf.default.accept_redirects = 0</pre>
</td>
<td xml:lang="en-US">An illicit ICMP redirect message could result in a man-in-the-middle attack.</td>
<td></td>
</tr>
<tr>
<td>3.2.3</td>
<td>Configure Kernel Parameter for Accepting Secure Redirects By Default</td>
<td xml:lang="en-US">To set the runtime status of the <code>net.ipv4.conf.default.secure_redirects</code> kernel parameter, run the following command: <pre>$ sudo sysctl -w net.ipv4.conf.default.secure_redirects=0</pre>
To make sure that the setting is persistent, add the following line to a file in the directory <code>/etc/sysctl.d</code>: <pre>net.ipv4.conf.default.secure_redirects = 0</pre>
</td>
<td xml:lang="en-US">Accepting "secure" ICMP redirects (from those gateways listed as
default gateways) has few legitimate uses. It should be disabled unless it is
absolutely required.</td>
<td></td>
</tr>
<tr>
<td>2.2.13</td>
<td>Disable Squid</td>
<td xml:lang="en-US"> The <code>squid</code> service can be disabled with the following command: <pre>$ sudo systemctl disable squid.service</pre> The <code>squid</code> service can be masked with the following command: <pre>$ sudo systemctl mask squid.service</pre>
</td>
<td xml:lang="en-US">Running proxy server software provides a network-based avenue
of attack, and should be removed if not needed.</td>
<td></td>
</tr>
<tr>
<td>2.2.1.1</td>
<td>The Chrony package is installed</td>
<td xml:lang="en-US">System time should be synchronized between all systems in an environment. This is
typically done by establishing an authoritative time server or set of servers and having all
systems synchronize their clocks to them.
The <code>chrony</code> package can be installed with the following command:
<pre>
$ sudo yum install chrony</pre>
</td>
<td xml:lang="en-US">Time synchronization is important to support time sensitive security mechanisms like
Kerberos and also ensures log files have consistent time records across the enterprise,
which aids in forensic investigations.</td>
<td></td>
</tr>
<tr>
<td>2.2.1.3</td>
<td>The Chronyd service is enabled</td>
<td xml:lang="en-US">chrony is a daemon which implements the Network Time Protocol (NTP) is designed to
synchronize system clocks across a variety of systems and use a source that is highly
accurate. More information on chrony can be found at

    <a href="http://chrony.tuxfamily.org/">http://chrony.tuxfamily.org/</a>.
Chrony can be configured to be a client and/or a server.
To enable Chronyd service, you can run:
<code># systemctl enable chronyd.service</code>
This recommendation only applies if chrony is in use on the system.</td>
<td xml:lang="en-US">If chrony is in use on the system proper configuration is vital to ensuring time
synchronization is working properly.</td>
<td></td>
</tr>
<tr>
<td>2.2.1.2</td>
<td>Configure server restrictions for ntpd</td>
<td xml:lang="en-US">ntpd is a daemon which implements the Network Time Protocol (NTP). It is designed to
synchronize system clocks across a variety of systems and use a source that is highly
accurate. More information on NTP can be found at

    <a href="http://www.ntp.org">http://www.ntp.org</a>.
ntp can be configured to be a client and/or a server.
To ensure that ntpd implements correct server restrictions, make sure that the following lines exist in the file <code>/etc/ntpd.conf</code>:
<pre>restrict -4 default kod nomodify notrap nopeer noquery</pre>
<pre>restrict -6 default kod nomodify notrap nopeer noquery</pre>
This recommendation only applies if ntp is in use on the system.</td>
<td xml:lang="en-US">If ntp is in use on the system proper configuration is vital to ensuring time synchronization
is working properly.</td>
<td></td>
</tr>
<tr>
<td>2.2.1.3</td>
<td>A remote time server for Chrony is configured</td>
<td xml:lang="en-US">
<code>Chrony</code> is a daemon which implements the Network Time Protocol (NTP). It is designed to
synchronize system clocks across a variety of systems and use a source that is highly
accurate. More information on <code>chrony</code> can be found at

    <a href="http://chrony.tuxfamily.org/">http://chrony.tuxfamily.org/</a>.
<code>Chrony</code> can be configured to be a client and/or a server.
Add or edit server or pool lines to <code>/etc/chrony.conf</code> as appropriate:
<pre>server &lt;remote-server&gt;</pre>
Multiple servers may be configured.</td>
<td xml:lang="en-US">If <code>chrony</code> is in use on the system proper configuration is vital to ensuring time
synchronization is working properly.</td>
<td></td>
</tr>
<tr>
<td>2.2.1.2</td>
<td>Configure ntpd To Run As ntp User</td>
<td xml:lang="en-US">ntp is a daemon which implements the Network Time Protocol (NTP). It is designed to
synchronize system clocks across a variety of systems and use a source that is highly
accurate. More information on NTP can be found at

    <a href="http://www.ntp.org">http://www.ntp.org</a>.
ntp can be configured to be a client and/or a server.
To ensure that ntpd is running as ntp user, Add or edit the
<code>OPTIONS</code> variable in <code>/etc/sysconfig/ntpd</code> to include ' -u ntp:ntp ':
<pre>OPTIONS="-u ntp:ntp"</pre>
This recommendation only applies if ntp is in use on the system.</td>
<td xml:lang="en-US">If ntp is in use on the system proper configuration is vital to ensuring time synchronization
is working properly. Running ntpd under dedicated user accounts limits the attack surface for
potential attacker exploiting security flaws in the daemon or the protocol.</td>
<td></td>
</tr>
<tr>
<td>2.2.1.3</td>
<td>Ensure that chronyd is running under chrony user account</td>
<td xml:lang="en-US">chrony is a daemon which implements the Network Time Protocol (NTP). It is designed to
synchronize system clocks across a variety of systems and use a source that is highly
accurate. More information on chrony can be found at

    <a href="http://chrony.tuxfamily.org/">http://chrony.tuxfamily.org/</a>.
Chrony can be configured to be a client and/or a server.
To ensure that chronyd is running under chrony user account, Add or edit the
<code>OPTIONS</code> variable in <code>/etc/sysconfig/chronyd</code> to include <code>-u chrony</code>:
<pre>OPTIONS="-u chrony"</pre>
This recommendation only applies if chrony is in use on the system.</td>
<td xml:lang="en-US">If chrony is in use on the system proper configuration is vital to ensuring time synchronization
is working properly.</td>
<td></td>
</tr>
<tr>
<td>5.2.1</td>
<td>Verify Permissions on SSH Server config file</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/ssh/sshd_config</code>, run the command:
<pre>$ sudo chmod 0600 /etc/ssh/sshd_config</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective
services that if configured incorrectly can lead to insecure and vulnerable
configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.2.1</td>
<td>Verify Owner on SSH Server config file</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/ssh/sshd_config</code>, run the command:
<pre>$ sudo chown root /etc/ssh/sshd_config </pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective
services that if configured incorrectly can lead to insecure and vulnerable
configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.2.1</td>
<td>Verify Group Who Owns SSH Server config file</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/ssh/sshd_config</code>, run the command:
<pre>$ sudo chgrp root /etc/ssh/sshd_config</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective
services that if configured incorrectly can lead to insecure and vulnerable
configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Do Not Allow SSH Environment Options</td>
<td xml:lang="en-US">To ensure users are not able to override environment
variables of the SSH daemon, add or correct the following line
in <code>/etc/ssh/sshd_config</code>:
<pre>PermitUserEnvironment no</pre>
</td>
<td xml:lang="en-US">SSH environment options potentially allow users to bypass
access restriction in some configurations.</td>
<td></td>
</tr>
<tr>
<td>5.2.6</td>
<td>Disable SSH Support for .rhosts Files</td>
<td xml:lang="en-US">SSH can emulate the behavior of the obsolete rsh
command in allowing users to enable insecure access to their
accounts via <code>.rhosts</code> files.
<br><br>
To ensure this behavior is disabled, add or correct the
following line in <code>/etc/ssh/sshd_config</code>:
<pre>IgnoreRhosts yes</pre>
</td>
<td xml:lang="en-US">SSH trust relationships mean a compromise on one host
can allow an attacker to move trivially to other hosts.</td>
<td></td>
</tr>
<tr>
<td>5.2.4</td>
<td>Disable X11 Forwarding</td>
<td xml:lang="en-US">The X11Forwarding parameter provides the ability to tunnel X11 traffic
through the connection to enable remote graphic connections.
SSH has the capability to encrypt remote X11 connections when SSH's
<code>X11Forwarding</code> option is enabled.
<br><br>
To disable X11 Forwarding, add or correct the
following line in <code>/etc/ssh/sshd_config</code>:
<pre>X11Forwarding no</pre>
</td>
<td xml:lang="en-US">Disable X11 forwarding unless there is an operational requirement to use X11
applications directly. There is a small risk that the remote X11 servers of
users who are logged in via SSH with X11 forwarding could be compromised by
other users on the X11 server. Note that even if X11 forwarding is disabled,
users can always install their own forwarders.</td>
<td></td>
</tr>
<tr>
<td>5.2.15</td>
<td>Enable SSH Warning Banner</td>
<td xml:lang="en-US">To enable the warning banner and ensure it is consistent
across the system, add or correct the following line in <code>/etc/ssh/sshd_config</code>:
<pre>Banner /etc/issue</pre>
Another section contains information on how to create an
appropriate system-wide warning banner.</td>
<td xml:lang="en-US">The warning message reinforces policy awareness during the logon process and
facilitates possible legal action against attackers. Alternatively, systems
whose ownership should not be obvious should ensure usage of a banner that does
not provide easy attribution.</td>
<td></td>
</tr>
<tr>
<td>5.2.12</td>
<td>Set SSH Idle Timeout Interval</td>
<td xml:lang="en-US">SSH allows administrators to set an idle timeout interval. After this interval
has passed, the idle user will be automatically logged out.
<br><br>
To set an idle timeout interval, edit the following line in <code>/etc/ssh/sshd_config</code> as
follows:
<pre>ClientAliveInterval <b><xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="sshd_idle_timeout_value"></xccdf-1.1:sub></b></pre>
<br><br>
The timeout <b>interval</b> is given in seconds. For example, have a timeout
of 10 minutes, set <b>interval</b> to 600.
<br><br>
If a shorter timeout has already been set for the login shell, that value will
preempt any SSH setting made in <code>/etc/ssh/sshd_config</code>. Keep in mind that
some processes may stop SSH  from correctly detecting that the user is idle.</td>
<td xml:lang="en-US">Terminating an idle ssh session within a short time period reduces the window of
opportunity for unauthorized personnel to take control of a management session
enabled on the console or console port that has been let unattended.</td>
<td></td>
</tr>
<tr>
<td>5.2.5</td>
<td>Set SSH authentication attempt limit</td>
<td xml:lang="en-US">The <code>MaxAuthTries</code> parameter specifies the maximum number of authentication attempts
permitted per connection. Once the number of failures reaches half this value, additional failures are logged.
to set MaxAUthTries edit <code>/etc/ssh/sshd_config</code> as follows:
<pre>MaxAuthTries <xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="sshd_max_auth_tries_value"></xccdf-1.1:sub></pre>
</td>
<td xml:lang="en-US">Setting the MaxAuthTries parameter to a low number will minimize the risk of successful
brute force attacks to the SSH server.</td>
<td></td>
</tr>
<tr>
<td>5.2.9</td>
<td>Disable SSH Access via Empty Passwords</td>
<td xml:lang="en-US">To explicitly disallow SSH login from accounts with
empty passwords, add or correct the following line in <code>/etc/ssh/sshd_config</code>:
<br>
<pre>PermitEmptyPasswords no</pre>
<br>
Any accounts with empty passwords should be disabled immediately, and PAM configuration
should prevent users from being able to assign themselves empty passwords.</td>
<td xml:lang="en-US">Configuring this setting for the SSH daemon provides additional assurance
that remote login via SSH will require a password, even in the event of
misconfiguration elsewhere.</td>
<td></td>
</tr>
<tr>
<td>5.2.8</td>
<td>Disable SSH Root Login</td>
<td xml:lang="en-US">The root user should never be allowed to login to a
system directly over a network.
To disable root login via SSH, add or correct the following line
in <code>/etc/ssh/sshd_config</code>:
<pre>PermitRootLogin no</pre>
</td>
<td xml:lang="en-US">Even though the communications channel may be encrypted, an additional layer of
security is gained by extending the policy of not logging directly on as root.
In addition, logging in with a user-specific account provides individual
accountability of actions performed on the system and also helps to minimize
direct attack attempts on root's password.</td>
<td></td>
</tr>
<tr>
<td>5.2.12</td>
<td>Use Only FIPS 140-2 Validated MACs</td>
<td xml:lang="en-US">Limit the MACs to those hash algorithms which are FIPS-approved.
The following line in <code>/etc/ssh/sshd_config</code>
demonstrates use of FIPS-approved MACs:

<pre>MACs hmac-sha2-512,hmac-sha2-256,hmac-sha1</pre>

The man page <code>sshd_config(5)</code> contains a list of supported MACs.

<br><br>
Only the following message authentication codes are FIPS 140-2 certified on Red Hat Enterprise Linux 7:
<br>- hmac-sha1
<br>- hmac-sha2-256
<br>- hmac-sha2-512
<br>- hmac-sha1-etm@openssh.com
<br>- hmac-sha2-256-etm@openssh.com
<br>- hmac-sha2-512-etm@openssh.com
<br><br>
Any combination of the above MACs will pass this check. Official FIPS 140-2 paperwork for
Red Hat Enterprise Linux 7 can be found at


    <a href="http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp2630.pdf">http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp2630.pdf</a>


The rule is parametrized to use the following MACs: <code><xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="sshd_approved_macs"></xccdf-1.1:sub></code>.</td>
<td xml:lang="en-US">DoD Information Systems are required to use FIPS-approved cryptographic hash
functions. The only SSHv2 hash algorithms meeting this requirement is SHA2.</td>
<td></td>
</tr>
<tr>
<td>5.2.7</td>
<td>Disable Host-Based Authentication</td>
<td xml:lang="en-US">SSH's cryptographic host-based authentication is
more secure than <code>.rhosts</code> authentication. However, it is
not recommended that hosts unilaterally trust one another, even
within an organization.
<br><br>
To disable host-based authentication, add or correct the
following line in <code>/etc/ssh/sshd_config</code>:
<pre>HostbasedAuthentication no</pre>
</td>
<td xml:lang="en-US">SSH trust relationships mean a compromise on one host
can allow an attacker to move trivially to other hosts.</td>
<td></td>
</tr>
<tr>
<td>5.2.10</td>
<td>Use Only FIPS 140-2 Validated Ciphers</td>
<td xml:lang="en-US">Limit the ciphers to those algorithms which are FIPS-approved.
Counter (CTR) mode is also preferred over cipher-block chaining (CBC) mode.
The following line in <code>/etc/ssh/sshd_config</code>
demonstrates use of FIPS-approved ciphers:
<pre>Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc</pre>
The man page <code>sshd_config(5)</code> contains a list of supported ciphers.

<br><br>
Only the following ciphers are FIPS 140-2 certified on Red Hat Enterprise Linux 7:
<br>- aes128-ctr
<br>- aes192-ctr
<br>- aes256-ctr
<br>- aes128-cbc
<br>- aes192-cbc
<br>- aes256-cbc
<br>- 3des-cbc
<br>- rijndael-cbc@lysator.liu.se
<br><br>
Any combination of the above ciphers will pass this check.
Official FIPS 140-2 paperwork for Red Hat Enterprise Linux 7 can be found at


    <a href="http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp2630.pdf">http://csrc.nist.gov/groups/STM/cmvp/documents/140-1/140sp/140sp2630.pdf</a>


The rule is parametrized to use the following ciphers: <code><xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="sshd_approved_ciphers"></xccdf-1.1:sub></code>.</td>
<td xml:lang="en-US">Unapproved mechanisms that are used for authentication to the cryptographic module are not verified and therefore
cannot be relied upon to provide confidentiality or integrity, and system data may be compromised.
<br>
Operating systems utilizing encryption are required to use FIPS-compliant mechanisms for authenticating to
cryptographic modules.
<br>
FIPS 140-2 is the current standard for validating that mechanisms used to access cryptographic modules
utilize authentication that meets industry and government requirements. For government systems, this allows
Security Levels 1, 2, 3, or 4 for use on Red Hat Enterprise Linux 7.</td>
<td></td>
</tr>
<tr>
<td>5.2.12</td>
<td>Set SSH Client Alive Max Count</td>
<td xml:lang="en-US">To ensure the SSH idle timeout occurs precisely when the <code>ClientAliveInterval</code> is set,
edit <code>/etc/ssh/sshd_config</code> as follows:
<pre>ClientAliveCountMax <xccdf-1.1:sub xmlns:xccdf-1.1="http://checklists.nist.gov/xccdf/1.1" idref="var_sshd_set_keepalive"></xccdf-1.1:sub></pre>
</td>
<td xml:lang="en-US">This ensures a user login will be terminated as soon as the <code>ClientAliveInterval</code>
is reached.</td>
<td></td>
</tr>
<tr>
<td>5.2.2</td>
<td>Allow Only SSH Protocol 2</td>
<td xml:lang="en-US">Only SSH protocol version 2 connections should be
permitted. The default setting in
<code>/etc/ssh/sshd_config</code> is correct, and can be
verified by ensuring that the following
line appears:
<pre>Protocol 2</pre>
</td>
<td xml:lang="en-US">SSH protocol version 1 is an insecure implementation of the SSH protocol and
has many well-known vulnerability exploits. Exploits of the SSH daemon could provide
immediate root access to the system.</td>
<td></td>
</tr>
<tr>
<td>5.2.3</td>
<td>Set LogLevel to INFO</td>
<td xml:lang="en-US">The INFO parameter specifices that record login and logout activity will be logged.
To specify the log level in
SSH, add or correct the following line in the <code>/etc/ssh/sshd_config</code> file:
<pre>LogLevel INFO</pre>
</td>
<td xml:lang="en-US">SSH provides several logging levels with varying amounts of verbosity. <code>DEBUG</code> is specifically
not recommended other than strictly for debugging SSH communications since it provides
so much data that it is difficult to identify important security information. <code>INFO</code> level is the
basic level that only records login activity of SSH users. In many situations, such as Incident
Response, it is important to determine when a particular user was active on a system. The
logout record can eliminate those users who disconnected, which helps narrow the field.</td>
<td></td>
</tr>
<tr>
<td>2.2.21</td>
<td>Ensure rsyncd service is diabled</td>
<td xml:lang="en-US">
The <code>rsyncd</code> service can be disabled with the following command:
<pre>$ sudo systemctl disable rsyncd.service</pre>
The <code>rsyncd</code> service can be masked with the following command:
<pre>$ sudo systemctl mask rsyncd.service</pre>
</td>
<td xml:lang="en-US">The rsyncd service presents a security risk as it uses unencrypted protocols for
communication.</td>
<td></td>
</tr>
<tr>
<td>3.4.1</td>
<td>Install tcp_wrappers Package</td>
<td xml:lang="en-US">When network services are using the <code>xinetd</code> service, the
<code>tcp_wrappers</code> package should be installed.
The <code>tcp_wrappers</code> package can be installed with the following command:
<pre>
$ sudo yum install tcp_wrappers</pre>
</td>
<td xml:lang="en-US">Access control methods provide the ability to enhance system security posture
by restricting services and known good IP addresses and address ranges. This
prevents connections from unknown hosts and protocols.</td>
<td></td>
</tr>
<tr>
<td>2.1.7</td>
<td>Disable xinetd Service</td>
<td xml:lang="en-US"> The <code>xinetd</code> service can be disabled with the following command: <pre>$ sudo systemctl disable xinetd.service</pre> The <code>xinetd</code> service can be masked with the following command: <pre>$ sudo systemctl mask xinetd.service</pre>
</td>
<td xml:lang="en-US">The xinetd service provides a dedicated listener service for some programs,
which is no longer necessary for commonly-used network services. Disabling
it ensures that these uncommon services are not running, and also prevents
attacks against xinetd itself.</td>
<td></td>
</tr>
<tr>
<td>3.4.4</td>
<td>Verify Permissions on /etc/hosts.allow</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/hosts.allow</code>, run the command:
<pre>$ sudo chmod 0644 /etc/hosts.allow</pre>
</td>
<td xml:lang="en-US">The <code>/etc/hosts.allow</code> file is used to control access of clients to daemons in the
server. Insecure groupownership of this file could allow users to grant clients unrestricted
access or no access at all to services in the server.</td>
<td></td>
</tr>
<tr>
<td>3.4.3</td>
<td>Ensure /etc/hosts.deny is configured</td>
<td xml:lang="en-US">The file <code>/etc/hosts.deny</code> together with <code>/etc/hosts.allow</code> provides a
simple access control mechanism for network services supporting TCP wrappers.
The following line in the file ensures that access to services supporting this mechanism is denied to any clients
not mentioned in <code>/etc/hosts.allow</code>:
<pre>ALL: ALL</pre>
It is advised to inspect available network services which might be affected by modification of file mentioned above prior to performing the remediation of this rule.
If there exist services which might be affected and access to them should not be blocked,
modify the <code>/etc/hosts.allow</code> file appropriately before performing the remediation.</td>
<td xml:lang="en-US">Correct configuration in <code>/etc/hosts.deny</code> ensures that no explicitly mentioned clients will be able to connect to services supporting this access control mechanism.</td>
<td></td>
</tr>
<tr>
<td>3.4.4</td>
<td>Verify Group Ownership of /etc/hosts.allow</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/hosts.allow</code>, run the command:
<pre>$ sudo chgrp root /etc/hosts.allow</pre>
</td>
<td xml:lang="en-US">The <code>/etc/hosts.allow</code> file is used to control access of clients to daemons in the
server. Insecure groupownership of this file could allow users to grant clients unrestricted
access or no access at all to services in the server.</td>
<td></td>
</tr>
<tr>
<td>3.4.5</td>
<td>Verify Ownership of /etc/hosts.deny</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/hosts.deny</code>, run the command:
<pre>$ sudo chown root /etc/hosts.deny </pre>
</td>
<td xml:lang="en-US">The <code>/etc/hosts.deny</code> file is used to control access of clients to daemons in the
server. Insecure groupownership of this file could allow users to grant clients unrestricted
access or no access at all to services in the server.</td>
<td></td>
</tr>
<tr>
<td>3.4.5</td>
<td>Verify Permissions on /etc/hosts.deny</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/hosts.deny</code>, run the command:
<pre>$ sudo chmod 0644 /etc/hosts.deny</pre>
</td>
<td xml:lang="en-US">The <code>/etc/hosts.deny</code> file is used to control access of clients to daemons in the
server. Insecure groupownership of this file could allow users to grant clients unrestricted
access or no access at all to services in the server.</td>
<td></td>
</tr>
<tr>
<td>3.4.5</td>
<td>Verify Group Ownership of /etc/hosts.deny</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/hosts.deny</code>, run the command:
<pre>$ sudo chgrp root /etc/hosts.deny</pre>
</td>
<td xml:lang="en-US">The <code>/etc/hosts.deny</code> file is used to control access of clients to daemons in the
server. Insecure groupownership of this file could allow users to grant clients unrestricted
access or no access at all to services in the server.</td>
<td></td>
</tr>
<tr>
<td>3.4.4</td>
<td>Verify Ownership of /etc/hosts.allow</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/hosts.allow</code>, run the command:
<pre>$ sudo chown root /etc/hosts.allow </pre>
</td>
<td xml:lang="en-US">The <code>/etc/hosts.allow</code> file is used to control access of clients to daemons in the
server. Insecure groupownership of this file could allow users to grant clients unrestricted
access or no access at all to services in the server.</td>
<td></td>
</tr>
<tr>
<td>2.1.6</td>
<td>Disable tftp Service</td>
<td xml:lang="en-US">The <code>tftp</code> service should be disabled.

The <code>tftp</code> service can be disabled with the following command:
<pre>$ sudo systemctl disable tftp.service</pre>
The <code>tftp</code> service can be masked with the following command:
<pre>$ sudo systemctl mask tftp.service</pre>
</td>
<td xml:lang="en-US">Disabling the <code>tftp</code> service ensures the system is not acting
as a TFTP server, which does not provide encryption or authentication.</td>
<td></td>
</tr>
<tr>
<td>2.1.1</td>
<td>Uninstall telnet-server Package</td>
<td xml:lang="en-US">The <code>telnet-server</code> package can be removed with the following command:
<pre>
$ sudo yum erase telnet-server</pre>
</td>
<td xml:lang="en-US">It is detrimental for operating systems to provide, or install by default,
functionality exceeding requirements or mission objectives. These
unnecessary capabilities are often overlooked and therefore may remain
unsecure. They increase the risk to the platform by providing additional
attack vectors.
<br>
The telnet service provides an unencrypted remote access service which does
not provide for the confidentiality and integrity of user passwords or the
remote session. If a privileged user were to login using this service, the
privileged user password could be compromised.
<br>
Removing the <code>telnet-server</code> package decreases the risk of the
telnet service's accidental (or intentional) activation.</td>
<td></td>
</tr>
<tr>
<td>2.2.18</td>
<td>Disable telnet Service</td>
<td xml:lang="en-US">The <code>telnet</code> service configuration file <code>/etc/xinetd.d/telnet</code>
is not created automatically. If it was created manually, check the
<code>/etc/xinetd.d/telnet</code> file and ensure that <code>disable = no</code>
is changed to read <code>disable = yes</code> as follows below:
<pre>
# description: The telnet server serves telnet sessions; it uses \\
#       unencrypted username/password pairs for authentication.
service telnet
{
        flags           = REUSE
        socket_type     = stream

        wait            = no
        user            = root
        server          = /usr/sbin/in.telnetd
        log_on_failure  += USERID
        disable         = yes
}
</pre>
If the <code>/etc/xinetd.d/telnet</code> file does not exist, make sure that
the activation of the <code>telnet</code> service on system boot is disabled
via the following command:

The <code>rexec</code> socket can be disabled with the following command:
<pre>$ sudo systemctl disable rexec.socket</pre>
The <code>rexec</code> socket can be masked with the following command:
<pre>$ sudo systemctl mask .socket</pre>
</td>
<td xml:lang="en-US">The telnet protocol uses unencrypted network communication, which
means that data from the login session, including passwords and
all other information transmitted during the session, can be
stolen by eavesdroppers on the network. The telnet protocol is also
subject to man-in-the-middle attacks.</td>
<td></td>
</tr>
<tr>
<td>2.3.2</td>
<td>Uninstall rsh Package</td>
<td xml:lang="en-US">The <code>rsh</code> package contains the client commands
for the rsh services</td>
<td xml:lang="en-US">These legacy clients contain numerous security exposures and have
been replaced with the more secure SSH package. Even if the server is removed,
it is best to ensure the clients are also removed to prevent users from
inadvertently attempting to use these commands and therefore exposing
their credentials. Note that removing the <code>rsh</code> package removes
the clients for <code>rsh</code>,<code>rcp</code>, and <code>rlogin</code>.</td>
<td></td>
</tr>
<tr>
<td>2.2.17</td>
<td>Disable rexec Service</td>
<td xml:lang="en-US">The <code>rexec</code> service, which is available with the <code>rsh-server</code> package
and runs as a service through xinetd or separately as a systemd socket, should be disabled.
If using xinetd, set <code>disable</code> to <code>yes</code> in <code>/etc/xinetd.d/rexec</code>.

The <code>rexec</code> socket can be disabled with the following command:
<pre>$ sudo systemctl disable rexec.socket</pre>
The <code>rexec</code> socket can be masked with the following command:
<pre>$ sudo systemctl mask .socket</pre>
</td>
<td xml:lang="en-US">The rexec service uses unencrypted network communications, which
means that data from the login session, including passwords and
all other information transmitted during the session, can be
stolen by eavesdroppers on the network.</td>
<td></td>
</tr>
<tr>
<td>2.2.17</td>
<td>Disable rlogin Service</td>
<td xml:lang="en-US">The <code>rlogin</code> service, which is available with
the <code>rsh-server</code> package and runs as a service through xinetd or separately
as a systemd socket, should be disabled.
If using xinetd, set <code>disable</code> to <code>yes</code> in <code>/etc/xinetd.d/rlogin</code>.

The <code>rlogin</code> socket can be disabled with the following command:
<pre>$ sudo systemctl disable rlogin.socket</pre>
The <code>rlogin</code> socket can be masked with the following command:
<pre>$ sudo systemctl mask .socket</pre>
</td>
<td xml:lang="en-US">The rlogin service uses unencrypted network communications, which
means that data from the login session, including passwords and
all other information transmitted during the session, can be
stolen by eavesdroppers on the network.</td>
<td></td>
</tr>
<tr>
<td>2.2.17</td>
<td>Disable rsh Service</td>
<td xml:lang="en-US">The <code>rsh</code> service, which is available with
the <code>rsh-server</code> package and runs as a service through xinetd or separately
as a systemd socket, should be disabled.
If using xinetd, set <code>disable</code> to <code>yes</code> in <code>/etc/xinetd.d/rsh</code>.

The <code>rsh</code> socket can be disabled with the following command:
<pre>$ sudo systemctl disable rsh.socket</pre>
The <code>rsh</code> socket can be masked with the following command:
<pre>$ sudo systemctl mask .socket</pre>
</td>
<td xml:lang="en-US">The rsh service uses unencrypted network communications, which
means that data from the login session, including passwords and
all other information transmitted during the session, can be
stolen by eavesdroppers on the network.</td>
<td></td>
</tr>
<tr>
<td>2.2.21</td>
<td>Uninstall talk-server Package</td>
<td xml:lang="en-US">The <code>talk-server</code> package can be removed with the following command: <pre> $ sudo yum erase talk-server</pre>
</td>
<td xml:lang="en-US">The talk software presents a security risk as it uses unencrypted protocols
for communications. Removing the <code>talk-server</code> package decreases the
risk of the accidental (or intentional) activation of talk services.</td>
<td></td>
</tr>
<tr>
<td>2.3.3</td>
<td>Uninstall talk Package</td>
<td xml:lang="en-US">The <code>talk</code> package contains the client program for the
Internet talk protocol, which allows the user to chat with other users on
different systems. Talk is a communication program which copies lines from one
terminal to the terminal of another user.
The <code>talk</code> package can be removed with the following command:
<pre>
$ sudo yum erase talk</pre>
</td>
<td xml:lang="en-US">The talk software presents a security risk as it uses unencrypted protocols
for communications. Removing the <code>talk</code> package decreases the
risk of the accidental (or intentional) activation of talk client program.</td>
<td></td>
</tr>
<tr>
<td>2.2.16</td>
<td>Uninstall ypserv Package</td>
<td xml:lang="en-US">The <code>ypserv</code> package can be removed with the following command:
<pre>
$ sudo yum erase ypserv</pre>
</td>
<td xml:lang="en-US">The NIS service provides an unencrypted authentication service which does
not provide for the confidentiality and integrity of user passwords or the
remote session.

Removing the <code>ypserv</code> package decreases the risk of the accidental
(or intentional) activation of NIS or NIS+ services.</td>
<td></td>
</tr>
<tr>
<td>5.1.2</td>
<td>Verify Permissions on crontab</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/crontab</code>, run the command:
<pre>$ sudo chmod 0600 /etc/crontab</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should have the
correct access rights to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.3</td>
<td>Verify Owner on cron.hourly</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/cron.hourly</code>, run the command:
<pre>$ sudo chown root /etc/cron.hourly </pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct user to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.5</td>
<td>Verify Group Who Owns cron.weekly</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/cron.weekly</code>, run the command:
<pre>$ sudo chgrp root /etc/cron.weekly</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.4</td>
<td>Verify Owner on cron.daily</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/cron.daily</code>, run the command:
<pre>$ sudo chown root /etc/cron.daily </pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct user to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.5</td>
<td>Verify Permissions on cron.weekly</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/cron.weekly</code>, run the command:
<pre>$ sudo chmod 0700 /etc/cron.weekly</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should have the
correct access rights to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.7</td>
<td>Verify Owner on cron.d</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/cron.d</code>, run the command:
<pre>$ sudo chown root /etc/cron.d </pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct user to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.3</td>
<td>Verify Group Who Owns cron.hourly</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/cron.hourly</code>, run the command:
<pre>$ sudo chgrp root /etc/cron.hourly</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.7</td>
<td>Verify Permissions on cron.d</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/cron.d</code>, run the command:
<pre>$ sudo chmod 0700 /etc/cron.d</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should have the
correct access rights to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.2</td>
<td>Verify Owner on crontab</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/crontab</code>, run the command:
<pre>$ sudo chown root /etc/crontab </pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct user to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.2</td>
<td>Verify Group Who Owns Crontab</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/crontab</code>, run the command:
<pre>$ sudo chgrp root /etc/crontab</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.6</td>
<td>Verify Permissions on cron.monthly</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/cron.monthly</code>, run the command:
<pre>$ sudo chmod 0700 /etc/cron.monthly</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should have the
correct access rights to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.7</td>
<td>Verify Group Who Owns cron.d</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/cron.d</code>, run the command:
<pre>$ sudo chgrp root /etc/cron.d</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.6</td>
<td>Verify Group Who Owns cron.monthly</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/cron.monthly</code>, run the command:
<pre>$ sudo chgrp root /etc/cron.monthly</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.6</td>
<td>Verify Owner on cron.monthly</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/cron.monthly</code>, run the command:
<pre>$ sudo chown root /etc/cron.monthly </pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct user to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.3</td>
<td>Verify Permissions on cron.hourly</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/cron.hourly</code>, run the command:
<pre>$ sudo chmod 0700 /etc/cron.hourly</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should have the
correct access rights to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.4</td>
<td>Verify Group Who Owns cron.daily</td>
<td xml:lang="en-US">
To properly set the group owner of <code>/etc/cron.daily</code>, run the command:
<pre>$ sudo chgrp root /etc/cron.daily</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct group to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.4</td>
<td>Verify Permissions on cron.daily</td>
<td xml:lang="en-US">
To properly set the permissions of <code>/etc/cron.daily</code>, run the command:
<pre>$ sudo chmod 0700 /etc/cron.daily</pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should have the
correct access rights to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>5.1.5</td>
<td>Verify Owner on cron.weekly</td>
<td xml:lang="en-US">
To properly set the owner of <code>/etc/cron.weekly</code>, run the command:
<pre>$ sudo chown root /etc/cron.weekly </pre>
</td>
<td xml:lang="en-US">Service configuration files enable or disable features of their respective services that if configured incorrectly
can lead to insecure and vulnerable configurations. Therefore, service configuration files should be owned by the
correct user to prevent unauthorized changes.</td>
<td></td>
</tr>
<tr>
<td>2.3.5</td>
<td>Ensure LDAP client is not installed</td>
<td xml:lang="en-US">The Lightweight Directory Access Protocol (LDAP) is a service that provides
a method for looking up information from a central database.
The <code>openldap-clients</code> package can be removed with the following command:
<pre>
$ sudo yum erase openldap-clients</pre>
</td>
<td xml:lang="en-US">If the system does not need to act as an LDAP client, it is recommended that the software is removed to reduce the potential attack surface.</td>
<td></td>
</tr>
</table>
</body>
</html>
