#!/bin/bash
###############################################################################
#
# Bash Remediation Script for CIS SUSE Linux Enterprise 15 Benchmark
#
# Profile Description:
# This baseline aligns to the Center for Internet Security
# SUSE Linux Enterprise 15 Benchmark, v1.0.0, currently in draft.
#
# Profile ID:  cis
# Benchmark ID:  SLE-15
# Benchmark Version:  0.1.52
# XCCDF Version:  1.1
#
# This file was generated by OpenSCAP 1.3.3 using:
# $ oscap xccdf generate fix --profile cis --fix-type bash xccdf-file.xml
#
# This Bash Remediation Script is generated from an OpenSCAP profile without preliminary evaluation.
# It attempts to fix every selected rule, even if the system is already compliant.
#
# How to apply this Bash Remediation Script:
# $ sudo ./remediation-script.sh
#
###############################################################################

###############################################################################
# BEGIN fix (1 / 201) for 'file_permissions_etc_issue'
###############################################################################
(>&2 echo "Remediating rule 1/201: 'file_permissions_etc_issue'")


chmod 0644 /etc/issue

# END fix for 'file_permissions_etc_issue'

###############################################################################
# BEGIN fix (2 / 201) for 'banner_etc_motd'
###############################################################################
(>&2 echo "Remediating rule 2/201: 'banner_etc_motd'")
(>&2 echo "FIX FOR THIS RULE 'banner_etc_motd' IS MISSING!")

# END fix for 'banner_etc_motd'

###############################################################################
# BEGIN fix (3 / 201) for 'file_permissions_etc_motd'
###############################################################################
(>&2 echo "Remediating rule 3/201: 'file_permissions_etc_motd'")


chmod 0644 /etc/motd

# END fix for 'file_permissions_etc_motd'

###############################################################################
# BEGIN fix (4 / 201) for 'banner_etc_issue'
###############################################################################
(>&2 echo "Remediating rule 4/201: 'banner_etc_issue'")
(>&2 echo "FIX FOR THIS RULE 'banner_etc_issue' IS MISSING!")

# END fix for 'banner_etc_issue'

###############################################################################
# BEGIN fix (5 / 201) for 'dconf_gnome_login_banner_text'
###############################################################################
(>&2 echo "Remediating rule 5/201: 'dconf_gnome_login_banner_text'")
(>&2 echo "FIX FOR THIS RULE 'dconf_gnome_login_banner_text' IS MISSING!")

# END fix for 'dconf_gnome_login_banner_text'

###############################################################################
# BEGIN fix (6 / 201) for 'dconf_gnome_banner_enabled'
###############################################################################
(>&2 echo "Remediating rule 6/201: 'dconf_gnome_banner_enabled'")
(>&2 echo "FIX FOR THIS RULE 'dconf_gnome_banner_enabled' IS MISSING!")

# END fix for 'dconf_gnome_banner_enabled'

###############################################################################
# BEGIN fix (7 / 201) for 'require_emergency_target_auth'
###############################################################################
(>&2 echo "Remediating rule 7/201: 'require_emergency_target_auth'")
(>&2 echo "FIX FOR THIS RULE 'require_emergency_target_auth' IS MISSING!")

# END fix for 'require_emergency_target_auth'

###############################################################################
# BEGIN fix (8 / 201) for 'require_singleuser_auth'
###############################################################################
(>&2 echo "Remediating rule 8/201: 'require_singleuser_auth'")
(>&2 echo "FIX FOR THIS RULE 'require_singleuser_auth' IS MISSING!")

# END fix for 'require_singleuser_auth'

###############################################################################
# BEGIN fix (9 / 201) for 'package_audit_installed'
###############################################################################
(>&2 echo "Remediating rule 9/201: 'package_audit_installed'")
(>&2 echo "FIX FOR THIS RULE 'package_audit_installed' IS MISSING!")

# END fix for 'package_audit_installed'

###############################################################################
# BEGIN fix (10 / 201) for 'service_auditd_enabled'
###############################################################################
(>&2 echo "Remediating rule 10/201: 'service_auditd_enabled'")
(>&2 echo "FIX FOR THIS RULE 'service_auditd_enabled' IS MISSING!")

# END fix for 'service_auditd_enabled'

###############################################################################
# BEGIN fix (11 / 201) for 'grub2_audit_argument'
###############################################################################
(>&2 echo "Remediating rule 11/201: 'grub2_audit_argument'")
(>&2 echo "FIX FOR THIS RULE 'grub2_audit_argument' IS MISSING!")

# END fix for 'grub2_audit_argument'

###############################################################################
# BEGIN fix (12 / 201) for 'grub2_audit_backlog_limit_argument'
###############################################################################
(>&2 echo "Remediating rule 12/201: 'grub2_audit_backlog_limit_argument'")
(>&2 echo "FIX FOR THIS RULE 'grub2_audit_backlog_limit_argument' IS MISSING!")

# END fix for 'grub2_audit_backlog_limit_argument'

###############################################################################
# BEGIN fix (13 / 201) for 'auditd_data_retention_action_mail_acct'
###############################################################################
(>&2 echo "Remediating rule 13/201: 'auditd_data_retention_action_mail_acct'")
(>&2 echo "FIX FOR THIS RULE 'auditd_data_retention_action_mail_acct' IS MISSING!")

# END fix for 'auditd_data_retention_action_mail_acct'

###############################################################################
# BEGIN fix (14 / 201) for 'auditd_data_retention_space_left_action'
###############################################################################
(>&2 echo "Remediating rule 14/201: 'auditd_data_retention_space_left_action'")
(>&2 echo "FIX FOR THIS RULE 'auditd_data_retention_space_left_action' IS MISSING!")

# END fix for 'auditd_data_retention_space_left_action'

###############################################################################
# BEGIN fix (15 / 201) for 'auditd_data_retention_admin_space_left_action'
###############################################################################
(>&2 echo "Remediating rule 15/201: 'auditd_data_retention_admin_space_left_action'")
(>&2 echo "FIX FOR THIS RULE 'auditd_data_retention_admin_space_left_action' IS MISSING!")

# END fix for 'auditd_data_retention_admin_space_left_action'

###############################################################################
# BEGIN fix (16 / 201) for 'auditd_data_retention_max_log_file_action'
###############################################################################
(>&2 echo "Remediating rule 16/201: 'auditd_data_retention_max_log_file_action'")
(>&2 echo "FIX FOR THIS RULE 'auditd_data_retention_max_log_file_action' IS MISSING!")

# END fix for 'auditd_data_retention_max_log_file_action'

###############################################################################
# BEGIN fix (17 / 201) for 'auditd_data_retention_max_log_file'
###############################################################################
(>&2 echo "Remediating rule 17/201: 'auditd_data_retention_max_log_file'")
(>&2 echo "FIX FOR THIS RULE 'auditd_data_retention_max_log_file' IS MISSING!")

# END fix for 'auditd_data_retention_max_log_file'

###############################################################################
# BEGIN fix (18 / 201) for 'audit_rules_mac_modification'
###############################################################################
(>&2 echo "Remediating rule 18/201: 'audit_rules_mac_modification'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_mac_modification' IS MISSING!")

# END fix for 'audit_rules_mac_modification'

###############################################################################
# BEGIN fix (19 / 201) for 'audit_rules_session_events'
###############################################################################
(>&2 echo "Remediating rule 19/201: 'audit_rules_session_events'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_session_events' IS MISSING!")

# END fix for 'audit_rules_session_events'

###############################################################################
# BEGIN fix (20 / 201) for 'audit_rules_networkconfig_modification'
###############################################################################
(>&2 echo "Remediating rule 20/201: 'audit_rules_networkconfig_modification'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_networkconfig_modification' IS MISSING!")

# END fix for 'audit_rules_networkconfig_modification'

###############################################################################
# BEGIN fix (21 / 201) for 'audit_rules_sysadmin_actions'
###############################################################################
(>&2 echo "Remediating rule 21/201: 'audit_rules_sysadmin_actions'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_sysadmin_actions' IS MISSING!")

# END fix for 'audit_rules_sysadmin_actions'

###############################################################################
# BEGIN fix (22 / 201) for 'audit_rules_time_stime'
###############################################################################
(>&2 echo "Remediating rule 22/201: 'audit_rules_time_stime'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_time_stime' IS MISSING!")

# END fix for 'audit_rules_time_stime'

###############################################################################
# BEGIN fix (23 / 201) for 'audit_rules_time_watch_localtime'
###############################################################################
(>&2 echo "Remediating rule 23/201: 'audit_rules_time_watch_localtime'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_time_watch_localtime' IS MISSING!")

# END fix for 'audit_rules_time_watch_localtime'

###############################################################################
# BEGIN fix (24 / 201) for 'audit_rules_time_settimeofday'
###############################################################################
(>&2 echo "Remediating rule 24/201: 'audit_rules_time_settimeofday'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_time_settimeofday' IS MISSING!")

# END fix for 'audit_rules_time_settimeofday'

###############################################################################
# BEGIN fix (25 / 201) for 'audit_rules_time_clock_settime'
###############################################################################
(>&2 echo "Remediating rule 25/201: 'audit_rules_time_clock_settime'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_time_clock_settime' IS MISSING!")

# END fix for 'audit_rules_time_clock_settime'

###############################################################################
# BEGIN fix (26 / 201) for 'audit_rules_time_adjtimex'
###############################################################################
(>&2 echo "Remediating rule 26/201: 'audit_rules_time_adjtimex'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_time_adjtimex' IS MISSING!")

# END fix for 'audit_rules_time_adjtimex'

###############################################################################
# BEGIN fix (27 / 201) for 'audit_rules_login_events_faillock'
###############################################################################
(>&2 echo "Remediating rule 27/201: 'audit_rules_login_events_faillock'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_login_events_faillock' IS MISSING!")

# END fix for 'audit_rules_login_events_faillock'

###############################################################################
# BEGIN fix (28 / 201) for 'audit_rules_login_events_lastlog'
###############################################################################
(>&2 echo "Remediating rule 28/201: 'audit_rules_login_events_lastlog'")
(>&2 echo "FIX FOR THIS RULE 'audit_rules_login_events_lastlog' IS MISSING!")

# END fix for 'audit_rules_login_events_lastlog'

###############################################################################
# BEGIN fix (29 / 201) for 'disable_prelink'
###############################################################################
(>&2 echo "Remediating rule 29/201: 'disable_prelink'")
# prelink not installed
if test -e /etc/sysconfig/prelink -o -e /usr/sbin/prelink; then
    if grep -q ^PRELINKING /etc/sysconfig/prelink
    then
        sed -i 's/^PRELINKING[:blank:]*=[:blank:]*[:alpha:]*/PRELINKING=no/' /etc/sysconfig/prelink
    else
        printf '\n' >> /etc/sysconfig/prelink
        printf '%s\n' '# Set PRELINKING=no per security requirements' 'PRELINKING=no' >> /etc/sysconfig/prelink
    fi

    # Undo previous prelink changes to binaries if prelink is available.
    if test -x /usr/sbin/prelink; then
        /usr/sbin/prelink -ua
    fi
fi

# END fix for 'disable_prelink'

###############################################################################
# BEGIN fix (30 / 201) for 'rpm_verify_ownership'
###############################################################################
(>&2 echo "Remediating rule 30/201: 'rpm_verify_ownership'")
(>&2 echo "FIX FOR THIS RULE 'rpm_verify_ownership' IS MISSING!")

# END fix for 'rpm_verify_ownership'

###############################################################################
# BEGIN fix (31 / 201) for 'rpm_verify_permissions'
###############################################################################
(>&2 echo "Remediating rule 31/201: 'rpm_verify_permissions'")
(>&2 echo "FIX FOR THIS RULE 'rpm_verify_permissions' IS MISSING!")

# END fix for 'rpm_verify_permissions'

###############################################################################
# BEGIN fix (32 / 201) for 'package_aide_installed'
###############################################################################
(>&2 echo "Remediating rule 32/201: 'package_aide_installed'")
(>&2 echo "FIX FOR THIS RULE 'package_aide_installed' IS MISSING!")

# END fix for 'package_aide_installed'

###############################################################################
# BEGIN fix (33 / 201) for 'aide_periodic_cron_checking'
###############################################################################
(>&2 echo "Remediating rule 33/201: 'aide_periodic_cron_checking'")
(>&2 echo "FIX FOR THIS RULE 'aide_periodic_cron_checking' IS MISSING!")

# END fix for 'aide_periodic_cron_checking'

###############################################################################
# BEGIN fix (34 / 201) for 'security_patches_up_to_date'
###############################################################################
(>&2 echo "Remediating rule 34/201: 'security_patches_up_to_date'")
(>&2 echo "FIX FOR THIS RULE 'security_patches_up_to_date' IS MISSING!")

# END fix for 'security_patches_up_to_date'

###############################################################################
# BEGIN fix (35 / 201) for 'ensure_gpgcheck_globally_activated'
###############################################################################
(>&2 echo "Remediating rule 35/201: 'ensure_gpgcheck_globally_activated'")
(>&2 echo "FIX FOR THIS RULE 'ensure_gpgcheck_globally_activated' IS MISSING!")

# END fix for 'ensure_gpgcheck_globally_activated'

###############################################################################
# BEGIN fix (36 / 201) for 'partition_for_var'
###############################################################################
(>&2 echo "Remediating rule 36/201: 'partition_for_var'")
(>&2 echo "FIX FOR THIS RULE 'partition_for_var' IS MISSING!")

# END fix for 'partition_for_var'

###############################################################################
# BEGIN fix (37 / 201) for 'partition_for_var_log'
###############################################################################
(>&2 echo "Remediating rule 37/201: 'partition_for_var_log'")
(>&2 echo "FIX FOR THIS RULE 'partition_for_var_log' IS MISSING!")

# END fix for 'partition_for_var_log'

###############################################################################
# BEGIN fix (38 / 201) for 'partition_for_var_tmp'
###############################################################################
(>&2 echo "Remediating rule 38/201: 'partition_for_var_tmp'")
(>&2 echo "FIX FOR THIS RULE 'partition_for_var_tmp' IS MISSING!")

# END fix for 'partition_for_var_tmp'

###############################################################################
# BEGIN fix (39 / 201) for 'partition_for_home'
###############################################################################
(>&2 echo "Remediating rule 39/201: 'partition_for_home'")
(>&2 echo "FIX FOR THIS RULE 'partition_for_home' IS MISSING!")

# END fix for 'partition_for_home'

###############################################################################
# BEGIN fix (40 / 201) for 'partition_for_tmp'
###############################################################################
(>&2 echo "Remediating rule 40/201: 'partition_for_tmp'")
(>&2 echo "FIX FOR THIS RULE 'partition_for_tmp' IS MISSING!")

# END fix for 'partition_for_tmp'

###############################################################################
# BEGIN fix (41 / 201) for 'partition_for_var_log_audit'
###############################################################################
(>&2 echo "Remediating rule 41/201: 'partition_for_var_log_audit'")
(>&2 echo "FIX FOR THIS RULE 'partition_for_var_log_audit' IS MISSING!")

# END fix for 'partition_for_var_log_audit'

###############################################################################
# BEGIN fix (42 / 201) for 'package_sudo_installed'
###############################################################################
(>&2 echo "Remediating rule 42/201: 'package_sudo_installed'")
(>&2 echo "FIX FOR THIS RULE 'package_sudo_installed' IS MISSING!")

# END fix for 'package_sudo_installed'

###############################################################################
# BEGIN fix (43 / 201) for 'grub2_password'
###############################################################################
(>&2 echo "Remediating rule 43/201: 'grub2_password'")
(>&2 echo "FIX FOR THIS RULE 'grub2_password' IS MISSING!")

# END fix for 'grub2_password'

###############################################################################
# BEGIN fix (44 / 201) for 'file_groupowner_grub2_cfg'
###############################################################################
(>&2 echo "Remediating rule 44/201: 'file_groupowner_grub2_cfg'")


chgrp 0 /boot/grub2/grub.cfg

# END fix for 'file_groupowner_grub2_cfg'

###############################################################################
# BEGIN fix (45 / 201) for 'file_permissions_grub2_cfg'
###############################################################################
(>&2 echo "Remediating rule 45/201: 'file_permissions_grub2_cfg'")


chmod 0600 /boot/grub2/grub.cfg

# END fix for 'file_permissions_grub2_cfg'

###############################################################################
# BEGIN fix (46 / 201) for 'file_owner_grub2_cfg'
###############################################################################
(>&2 echo "Remediating rule 46/201: 'file_owner_grub2_cfg'")


chown 0 /boot/grub2/grub.cfg

# END fix for 'file_owner_grub2_cfg'

###############################################################################
# BEGIN fix (47 / 201) for 'sysctl_net_ipv4_conf_default_send_redirects'
###############################################################################
(>&2 echo "Remediating rule 47/201: 'sysctl_net_ipv4_conf_default_send_redirects'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_default_send_redirects' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_default_send_redirects'

###############################################################################
# BEGIN fix (48 / 201) for 'sysctl_net_ipv4_conf_all_send_redirects'
###############################################################################
(>&2 echo "Remediating rule 48/201: 'sysctl_net_ipv4_conf_all_send_redirects'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_all_send_redirects' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_all_send_redirects'

###############################################################################
# BEGIN fix (49 / 201) for 'sysctl_net_ipv4_ip_forward'
###############################################################################
(>&2 echo "Remediating rule 49/201: 'sysctl_net_ipv4_ip_forward'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_ip_forward' IS MISSING!")

# END fix for 'sysctl_net_ipv4_ip_forward'

###############################################################################
# BEGIN fix (50 / 201) for 'sysctl_net_ipv4_icmp_ignore_bogus_error_responses'
###############################################################################
(>&2 echo "Remediating rule 50/201: 'sysctl_net_ipv4_icmp_ignore_bogus_error_responses'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_icmp_ignore_bogus_error_responses' IS MISSING!")

# END fix for 'sysctl_net_ipv4_icmp_ignore_bogus_error_responses'

###############################################################################
# BEGIN fix (51 / 201) for 'sysctl_net_ipv4_conf_default_secure_redirects'
###############################################################################
(>&2 echo "Remediating rule 51/201: 'sysctl_net_ipv4_conf_default_secure_redirects'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_default_secure_redirects' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_default_secure_redirects'

###############################################################################
# BEGIN fix (52 / 201) for 'sysctl_net_ipv4_tcp_syncookies'
###############################################################################
(>&2 echo "Remediating rule 52/201: 'sysctl_net_ipv4_tcp_syncookies'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_tcp_syncookies' IS MISSING!")

# END fix for 'sysctl_net_ipv4_tcp_syncookies'

###############################################################################
# BEGIN fix (53 / 201) for 'sysctl_net_ipv4_icmp_echo_ignore_broadcasts'
###############################################################################
(>&2 echo "Remediating rule 53/201: 'sysctl_net_ipv4_icmp_echo_ignore_broadcasts'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_icmp_echo_ignore_broadcasts' IS MISSING!")

# END fix for 'sysctl_net_ipv4_icmp_echo_ignore_broadcasts'

###############################################################################
# BEGIN fix (54 / 201) for 'sysctl_net_ipv4_conf_all_accept_source_route'
###############################################################################
(>&2 echo "Remediating rule 54/201: 'sysctl_net_ipv4_conf_all_accept_source_route'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_all_accept_source_route' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_all_accept_source_route'

###############################################################################
# BEGIN fix (55 / 201) for 'sysctl_net_ipv4_conf_default_accept_source_route'
###############################################################################
(>&2 echo "Remediating rule 55/201: 'sysctl_net_ipv4_conf_default_accept_source_route'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_default_accept_source_route' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_default_accept_source_route'

###############################################################################
# BEGIN fix (56 / 201) for 'sysctl_net_ipv4_conf_all_secure_redirects'
###############################################################################
(>&2 echo "Remediating rule 56/201: 'sysctl_net_ipv4_conf_all_secure_redirects'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_all_secure_redirects' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_all_secure_redirects'

###############################################################################
# BEGIN fix (57 / 201) for 'sysctl_net_ipv4_conf_all_accept_redirects'
###############################################################################
(>&2 echo "Remediating rule 57/201: 'sysctl_net_ipv4_conf_all_accept_redirects'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_all_accept_redirects' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_all_accept_redirects'

###############################################################################
# BEGIN fix (58 / 201) for 'sysctl_net_ipv4_conf_default_rp_filter'
###############################################################################
(>&2 echo "Remediating rule 58/201: 'sysctl_net_ipv4_conf_default_rp_filter'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_default_rp_filter' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_default_rp_filter'

###############################################################################
# BEGIN fix (59 / 201) for 'sysctl_net_ipv4_conf_all_rp_filter'
###############################################################################
(>&2 echo "Remediating rule 59/201: 'sysctl_net_ipv4_conf_all_rp_filter'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_all_rp_filter' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_all_rp_filter'

###############################################################################
# BEGIN fix (60 / 201) for 'sysctl_net_ipv4_conf_default_log_martians'
###############################################################################
(>&2 echo "Remediating rule 60/201: 'sysctl_net_ipv4_conf_default_log_martians'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_default_log_martians' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_default_log_martians'

###############################################################################
# BEGIN fix (61 / 201) for 'sysctl_net_ipv4_conf_default_accept_redirects'
###############################################################################
(>&2 echo "Remediating rule 61/201: 'sysctl_net_ipv4_conf_default_accept_redirects'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_default_accept_redirects' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_default_accept_redirects'

###############################################################################
# BEGIN fix (62 / 201) for 'sysctl_net_ipv4_conf_all_log_martians'
###############################################################################
(>&2 echo "Remediating rule 62/201: 'sysctl_net_ipv4_conf_all_log_martians'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv4_conf_all_log_martians' IS MISSING!")

# END fix for 'sysctl_net_ipv4_conf_all_log_martians'

###############################################################################
# BEGIN fix (63 / 201) for 'service_firewalld_enabled'
###############################################################################
(>&2 echo "Remediating rule 63/201: 'service_firewalld_enabled'")
(>&2 echo "FIX FOR THIS RULE 'service_firewalld_enabled' IS MISSING!")

# END fix for 'service_firewalld_enabled'

###############################################################################
# BEGIN fix (64 / 201) for 'set_firewalld_default_zone'
###############################################################################
(>&2 echo "Remediating rule 64/201: 'set_firewalld_default_zone'")
(>&2 echo "FIX FOR THIS RULE 'set_firewalld_default_zone' IS MISSING!")

# END fix for 'set_firewalld_default_zone'

###############################################################################
# BEGIN fix (65 / 201) for 'grub2_ipv6_disable_argument'
###############################################################################
(>&2 echo "Remediating rule 65/201: 'grub2_ipv6_disable_argument'")
(>&2 echo "FIX FOR THIS RULE 'grub2_ipv6_disable_argument' IS MISSING!")

# END fix for 'grub2_ipv6_disable_argument'

###############################################################################
# BEGIN fix (66 / 201) for 'sysctl_net_ipv6_conf_all_accept_ra'
###############################################################################
(>&2 echo "Remediating rule 66/201: 'sysctl_net_ipv6_conf_all_accept_ra'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv6_conf_all_accept_ra' IS MISSING!")

# END fix for 'sysctl_net_ipv6_conf_all_accept_ra'

###############################################################################
# BEGIN fix (67 / 201) for 'sysctl_net_ipv6_conf_default_accept_ra'
###############################################################################
(>&2 echo "Remediating rule 67/201: 'sysctl_net_ipv6_conf_default_accept_ra'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_net_ipv6_conf_default_accept_ra' IS MISSING!")

# END fix for 'sysctl_net_ipv6_conf_default_accept_ra'

###############################################################################
# BEGIN fix (68 / 201) for 'wireless_disable_interfaces'
###############################################################################
(>&2 echo "Remediating rule 68/201: 'wireless_disable_interfaces'")
(>&2 echo "FIX FOR THIS RULE 'wireless_disable_interfaces' IS MISSING!")

# END fix for 'wireless_disable_interfaces'

###############################################################################
# BEGIN fix (69 / 201) for 'package_iptables_installed'
###############################################################################
(>&2 echo "Remediating rule 69/201: 'package_iptables_installed'")
(>&2 echo "FIX FOR THIS RULE 'package_iptables_installed' IS MISSING!")

# END fix for 'package_iptables_installed'

###############################################################################
# BEGIN fix (70 / 201) for 'service_ip6tables_enabled'
###############################################################################
(>&2 echo "Remediating rule 70/201: 'service_ip6tables_enabled'")
(>&2 echo "FIX FOR THIS RULE 'service_ip6tables_enabled' IS MISSING!")

# END fix for 'service_ip6tables_enabled'

###############################################################################
# BEGIN fix (71 / 201) for 'service_iptables_enabled'
###############################################################################
(>&2 echo "Remediating rule 71/201: 'service_iptables_enabled'")
(>&2 echo "FIX FOR THIS RULE 'service_iptables_enabled' IS MISSING!")

# END fix for 'service_iptables_enabled'

###############################################################################
# BEGIN fix (72 / 201) for 'set_ip6tables_default_rule'
###############################################################################
(>&2 echo "Remediating rule 72/201: 'set_ip6tables_default_rule'")
(>&2 echo "FIX FOR THIS RULE 'set_ip6tables_default_rule' IS MISSING!")

# END fix for 'set_ip6tables_default_rule'

###############################################################################
# BEGIN fix (73 / 201) for 'set_iptables_default_rule'
###############################################################################
(>&2 echo "Remediating rule 73/201: 'set_iptables_default_rule'")
(>&2 echo "FIX FOR THIS RULE 'set_iptables_default_rule' IS MISSING!")

# END fix for 'set_iptables_default_rule'

###############################################################################
# BEGIN fix (74 / 201) for 'kernel_module_sctp_disabled'
###############################################################################
(>&2 echo "Remediating rule 74/201: 'kernel_module_sctp_disabled'")
(>&2 echo "FIX FOR THIS RULE 'kernel_module_sctp_disabled' IS MISSING!")

# END fix for 'kernel_module_sctp_disabled'

###############################################################################
# BEGIN fix (75 / 201) for 'kernel_module_dccp_disabled'
###############################################################################
(>&2 echo "Remediating rule 75/201: 'kernel_module_dccp_disabled'")
(>&2 echo "FIX FOR THIS RULE 'kernel_module_dccp_disabled' IS MISSING!")

# END fix for 'kernel_module_dccp_disabled'

###############################################################################
# BEGIN fix (76 / 201) for 'package_rsyslog_installed'
###############################################################################
(>&2 echo "Remediating rule 76/201: 'package_rsyslog_installed'")
(>&2 echo "FIX FOR THIS RULE 'package_rsyslog_installed' IS MISSING!")

# END fix for 'package_rsyslog_installed'

###############################################################################
# BEGIN fix (77 / 201) for 'service_rsyslog_enabled'
###############################################################################
(>&2 echo "Remediating rule 77/201: 'service_rsyslog_enabled'")
(>&2 echo "FIX FOR THIS RULE 'service_rsyslog_enabled' IS MISSING!")

# END fix for 'service_rsyslog_enabled'

###############################################################################
# BEGIN fix (78 / 201) for 'rsyslog_remote_loghost'
###############################################################################
(>&2 echo "Remediating rule 78/201: 'rsyslog_remote_loghost'")
(>&2 echo "FIX FOR THIS RULE 'rsyslog_remote_loghost' IS MISSING!")

# END fix for 'rsyslog_remote_loghost'

###############################################################################
# BEGIN fix (79 / 201) for 'rsyslog_files_permissions'
###############################################################################
(>&2 echo "Remediating rule 79/201: 'rsyslog_files_permissions'")
(>&2 echo "FIX FOR THIS RULE 'rsyslog_files_permissions' IS MISSING!")

# END fix for 'rsyslog_files_permissions'

###############################################################################
# BEGIN fix (80 / 201) for 'rsyslog_files_ownership'
###############################################################################
(>&2 echo "Remediating rule 80/201: 'rsyslog_files_ownership'")
(>&2 echo "FIX FOR THIS RULE 'rsyslog_files_ownership' IS MISSING!")

# END fix for 'rsyslog_files_ownership'

###############################################################################
# BEGIN fix (81 / 201) for 'rsyslog_files_groupownership'
###############################################################################
(>&2 echo "Remediating rule 81/201: 'rsyslog_files_groupownership'")
(>&2 echo "FIX FOR THIS RULE 'rsyslog_files_groupownership' IS MISSING!")

# END fix for 'rsyslog_files_groupownership'

###############################################################################
# BEGIN fix (82 / 201) for 'ensure_logrotate_activated'
###############################################################################
(>&2 echo "Remediating rule 82/201: 'ensure_logrotate_activated'")

LOGROTATE_CONF_FILE="/etc/logrotate.conf"
CRON_DAILY_LOGROTATE_FILE="/etc/cron.daily/logrotate"

# daily rotation is configured
grep -q "^daily$" $LOGROTATE_CONF_FILE|| echo "daily" >> $LOGROTATE_CONF_FILE

# remove any line configuring weekly, monthly or yearly rotation
sed -i -r "/^(weekly|monthly|yearly)$/d" $LOGROTATE_CONF_FILE

# configure cron.daily if not already
if ! grep -q "^[[:space:]]*/usr/sbin/logrotate[[:alnum:][:blank:][:punct:]]*$LOGROTATE_CONF_FILE$" $CRON_DAILY_LOGROTATE_FILE; then
	echo "#!/bin/sh" > $CRON_DAILY_LOGROTATE_FILE
	echo "/usr/sbin/logrotate $LOGROTATE_CONF_FILE" >> $CRON_DAILY_LOGROTATE_FILE
fi

# END fix for 'ensure_logrotate_activated'

###############################################################################
# BEGIN fix (83 / 201) for 'service_autofs_disabled'
###############################################################################
(>&2 echo "Remediating rule 83/201: 'service_autofs_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'autofs.service'
"$SYSTEMCTL_EXEC" disable 'autofs.service'
"$SYSTEMCTL_EXEC" mask 'autofs.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^autofs.socket'; then
    "$SYSTEMCTL_EXEC" stop 'autofs.socket'
    "$SYSTEMCTL_EXEC" disable 'autofs.socket'
    "$SYSTEMCTL_EXEC" mask 'autofs.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'autofs.service' || true

# END fix for 'service_autofs_disabled'

###############################################################################
# BEGIN fix (84 / 201) for 'kernel_module_usb-storage_disabled'
###############################################################################
(>&2 echo "Remediating rule 84/201: 'kernel_module_usb-storage_disabled'")
(>&2 echo "FIX FOR THIS RULE 'kernel_module_usb-storage_disabled' IS MISSING!")

# END fix for 'kernel_module_usb-storage_disabled'

###############################################################################
# BEGIN fix (85 / 201) for 'kernel_module_cramfs_disabled'
###############################################################################
(>&2 echo "Remediating rule 85/201: 'kernel_module_cramfs_disabled'")
(>&2 echo "FIX FOR THIS RULE 'kernel_module_cramfs_disabled' IS MISSING!")

# END fix for 'kernel_module_cramfs_disabled'

###############################################################################
# BEGIN fix (86 / 201) for 'kernel_module_udf_disabled'
###############################################################################
(>&2 echo "Remediating rule 86/201: 'kernel_module_udf_disabled'")
(>&2 echo "FIX FOR THIS RULE 'kernel_module_udf_disabled' IS MISSING!")

# END fix for 'kernel_module_udf_disabled'

###############################################################################
# BEGIN fix (87 / 201) for 'kernel_module_squashfs_disabled'
###############################################################################
(>&2 echo "Remediating rule 87/201: 'kernel_module_squashfs_disabled'")
(>&2 echo "FIX FOR THIS RULE 'kernel_module_squashfs_disabled' IS MISSING!")

# END fix for 'kernel_module_squashfs_disabled'

###############################################################################
# BEGIN fix (88 / 201) for 'kernel_module_vfat_disabled'
###############################################################################
(>&2 echo "Remediating rule 88/201: 'kernel_module_vfat_disabled'")
(>&2 echo "FIX FOR THIS RULE 'kernel_module_vfat_disabled' IS MISSING!")

# END fix for 'kernel_module_vfat_disabled'

###############################################################################
# BEGIN fix (89 / 201) for 'mount_option_tmp_nodev'
###############################################################################
(>&2 echo "Remediating rule 89/201: 'mount_option_tmp_nodev'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /tmp || { echo "Not remediating, because there is no record of /tmp in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/tmp" "nodev" "" ""

	ensure_partition_is_mounted "/tmp"
}

perform_remediation

# END fix for 'mount_option_tmp_nodev'

###############################################################################
# BEGIN fix (90 / 201) for 'mount_option_dev_shm_nosuid'
###############################################################################
(>&2 echo "Remediating rule 90/201: 'mount_option_dev_shm_nosuid'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "no" = 'yes'; then
		assert_mount_point_in_fstab /dev/shm || { echo "Not remediating, because there is no record of /dev/shm in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/dev/shm" "nosuid" "tmpfs" "tmpfs"

	ensure_partition_is_mounted "/dev/shm"
}

perform_remediation

# END fix for 'mount_option_dev_shm_nosuid'

###############################################################################
# BEGIN fix (91 / 201) for 'mount_option_var_tmp_noexec'
###############################################################################
(>&2 echo "Remediating rule 91/201: 'mount_option_var_tmp_noexec'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/tmp || { echo "Not remediating, because there is no record of /var/tmp in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/tmp" "noexec" "" ""

	ensure_partition_is_mounted "/var/tmp"
}

perform_remediation

# END fix for 'mount_option_var_tmp_noexec'

###############################################################################
# BEGIN fix (92 / 201) for 'mount_option_var_tmp_nosuid'
###############################################################################
(>&2 echo "Remediating rule 92/201: 'mount_option_var_tmp_nosuid'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/tmp || { echo "Not remediating, because there is no record of /var/tmp in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/tmp" "nosuid" "" ""

	ensure_partition_is_mounted "/var/tmp"
}

perform_remediation

# END fix for 'mount_option_var_tmp_nosuid'

###############################################################################
# BEGIN fix (93 / 201) for 'mount_option_dev_shm_nodev'
###############################################################################
(>&2 echo "Remediating rule 93/201: 'mount_option_dev_shm_nodev'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "no" = 'yes'; then
		assert_mount_point_in_fstab /dev/shm || { echo "Not remediating, because there is no record of /dev/shm in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/dev/shm" "nodev" "tmpfs" "tmpfs"

	ensure_partition_is_mounted "/dev/shm"
}

perform_remediation

# END fix for 'mount_option_dev_shm_nodev'

###############################################################################
# BEGIN fix (94 / 201) for 'mount_option_nosuid_removable_partitions'
###############################################################################
(>&2 echo "Remediating rule 94/201: 'mount_option_nosuid_removable_partitions'")

var_removable_partition="/dev/cdrom"

device_regex="^\s*$var_removable_partition\s\+"
mount_option="nosuid"

if grep -q $device_regex /etc/fstab ; then
    previous_opts=$(grep $device_regex /etc/fstab | awk '{print $4}')
    sed -i "s|\($device_regex.*$previous_opts\)|\1,$mount_option|" /etc/fstab
else
    echo "Not remediating, because there is no record of $var_removable_partition in /etc/fstab" >&2
    return 1
fi

# END fix for 'mount_option_nosuid_removable_partitions'

###############################################################################
# BEGIN fix (95 / 201) for 'mount_option_home_nodev'
###############################################################################
(>&2 echo "Remediating rule 95/201: 'mount_option_home_nodev'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /home || { echo "Not remediating, because there is no record of /home in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/home" "nodev" "" ""

	ensure_partition_is_mounted "/home"
}

perform_remediation

# END fix for 'mount_option_home_nodev'

###############################################################################
# BEGIN fix (96 / 201) for 'mount_option_var_tmp_nodev'
###############################################################################
(>&2 echo "Remediating rule 96/201: 'mount_option_var_tmp_nodev'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /var/tmp || { echo "Not remediating, because there is no record of /var/tmp in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/var/tmp" "nodev" "" ""

	ensure_partition_is_mounted "/var/tmp"
}

perform_remediation

# END fix for 'mount_option_var_tmp_nodev'

###############################################################################
# BEGIN fix (97 / 201) for 'mount_option_noexec_removable_partitions'
###############################################################################
(>&2 echo "Remediating rule 97/201: 'mount_option_noexec_removable_partitions'")

var_removable_partition="/dev/cdrom"

device_regex="^\s*$var_removable_partition\s\+"
mount_option="noexec"

if grep -q $device_regex /etc/fstab ; then
    previous_opts=$(grep $device_regex /etc/fstab | awk '{print $4}')
    sed -i "s|\($device_regex.*$previous_opts\)|\1,$mount_option|" /etc/fstab
else
    echo "Not remediating, because there is no record of $var_removable_partition in /etc/fstab" >&2
    return 1
fi

# END fix for 'mount_option_noexec_removable_partitions'

###############################################################################
# BEGIN fix (98 / 201) for 'mount_option_nodev_removable_partitions'
###############################################################################
(>&2 echo "Remediating rule 98/201: 'mount_option_nodev_removable_partitions'")

var_removable_partition="/dev/cdrom"

device_regex="^\s*$var_removable_partition\s\+"
mount_option="nodev"

if grep -q $device_regex /etc/fstab ; then
    previous_opts=$(grep $device_regex /etc/fstab | awk '{print $4}')
    sed -i "s|\($device_regex.*$previous_opts\)|\1,$mount_option|" /etc/fstab
else
    echo "Not remediating, because there is no record of $var_removable_partition in /etc/fstab" >&2
    return 1
fi

# END fix for 'mount_option_nodev_removable_partitions'

###############################################################################
# BEGIN fix (99 / 201) for 'mount_option_tmp_noexec'
###############################################################################
(>&2 echo "Remediating rule 99/201: 'mount_option_tmp_noexec'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /tmp || { echo "Not remediating, because there is no record of /tmp in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/tmp" "noexec" "" ""

	ensure_partition_is_mounted "/tmp"
}

perform_remediation

# END fix for 'mount_option_tmp_noexec'

###############################################################################
# BEGIN fix (100 / 201) for 'mount_option_tmp_nosuid'
###############################################################################
(>&2 echo "Remediating rule 100/201: 'mount_option_tmp_nosuid'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "yes" = 'yes'; then
		assert_mount_point_in_fstab /tmp || { echo "Not remediating, because there is no record of /tmp in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/tmp" "nosuid" "" ""

	ensure_partition_is_mounted "/tmp"
}

perform_remediation

# END fix for 'mount_option_tmp_nosuid'

###############################################################################
# BEGIN fix (101 / 201) for 'mount_option_dev_shm_noexec'
###############################################################################
(>&2 echo "Remediating rule 101/201: 'mount_option_dev_shm_noexec'")
function include_mount_options_functions {
	:
}

# $1: type of filesystem
# $2: new mount point option
# $3: filesystem of new mount point (used when adding new entry in fstab)
# $4: mount type of new mount point (used when adding new entry in fstab)
function ensure_mount_option_for_vfstype {
        local _vfstype="$1" _new_opt="$2" _filesystem=$3 _type=$4 _vfstype_points=()
        readarray -t _vfstype_points < <(grep -E "[[:space:]]${_vfstype}[[:space:]]" /etc/fstab | awk '{print $2}')

        for _vfstype_point in "${_vfstype_points[@]}"
        do
                ensure_mount_option_in_fstab "$_vfstype_point" "$_new_opt" "$_filesystem" "$_type"
        done
}

# $1: mount point
# $2: new mount point option
# $3: device or virtual string (used when adding new entry in fstab)
# $4: mount type of mount point (used when adding new entry in fstab)
function ensure_mount_option_in_fstab {
	local _mount_point="$1" _new_opt="$2" _device=$3 _type=$4
	local _mount_point_match_regexp="" _previous_mount_opts=""
	_mount_point_match_regexp="$(get_mount_point_regexp "$_mount_point")"

	if [ "$(grep -c "$_mount_point_match_regexp" /etc/fstab)" -eq 0 ]; then
		# runtime opts without some automatic kernel/userspace-added defaults
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/mtab | head -1 |  awk '{print $4}' \
					| sed -E "s/(rw|defaults|seclabel|${_new_opt})(,|$)//g;s/,$//")
		[ "$_previous_mount_opts" ] && _previous_mount_opts+=","
		echo "${_device} ${_mount_point} ${_type} defaults,${_previous_mount_opts}${_new_opt} 0 0" >> /etc/fstab
	elif [ "$(grep "$_mount_point_match_regexp" /etc/fstab | grep -c "$_new_opt")" -eq 0 ]; then
		_previous_mount_opts=$(grep "$_mount_point_match_regexp" /etc/fstab | awk '{print $4}')
		sed -i "s|\(${_mount_point_match_regexp}.*${_previous_mount_opts}\)|\1,${_new_opt}|" /etc/fstab
	fi
}

# $1: mount point
function get_mount_point_regexp {
		printf "[[:space:]]%s[[:space:]]" "$1"
}

# $1: mount point
function assert_mount_point_in_fstab {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	grep "$_mount_point_match_regexp" -q /etc/fstab \
		|| { echo "The mount point '$1' is not even in /etc/fstab, so we can't set up mount options" >&2; return 1; }
}

# $1: mount point
function remove_defaults_from_fstab_if_overriden {
	local _mount_point_match_regexp
	_mount_point_match_regexp="$(get_mount_point_regexp "$1")"
	if grep "$_mount_point_match_regexp" /etc/fstab | grep -q "defaults,"
	then
		sed -i "s|\(${_mount_point_match_regexp}.*\)defaults,|\1|" /etc/fstab
	fi
}

# $1: mount point
function ensure_partition_is_mounted {
	local _mount_point="$1"
	mkdir -p "$_mount_point" || return 1
	if mountpoint -q "$_mount_point"; then
		mount -o remount --target "$_mount_point"
	else
		mount --target "$_mount_point"
	fi
}
include_mount_options_functions

function perform_remediation {
	# test "$mount_has_to_exist" = 'yes'
	if test "no" = 'yes'; then
		assert_mount_point_in_fstab /dev/shm || { echo "Not remediating, because there is no record of /dev/shm in /etc/fstab" >&2; return 1; }
	fi

	ensure_mount_option_in_fstab "/dev/shm" "noexec" "tmpfs" "tmpfs"

	ensure_partition_is_mounted "/dev/shm"
}

perform_remediation

# END fix for 'mount_option_dev_shm_noexec'

###############################################################################
# BEGIN fix (102 / 201) for 'sysctl_fs_suid_dumpable'
###############################################################################
(>&2 echo "Remediating rule 102/201: 'sysctl_fs_suid_dumpable'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_fs_suid_dumpable' IS MISSING!")

# END fix for 'sysctl_fs_suid_dumpable'

###############################################################################
# BEGIN fix (103 / 201) for 'coredump_disable_backtraces'
###############################################################################
(>&2 echo "Remediating rule 103/201: 'coredump_disable_backtraces'")
if [ -e "/etc/systemd/coredump.conf" ] ; then
    LC_ALL=C sed -i "/^\s*ProcessSizeMax\s*=\s*/Id" "/etc/systemd/coredump.conf"
else
    touch "/etc/systemd/coredump.conf"
fi
cp "/etc/systemd/coredump.conf" "/etc/systemd/coredump.conf.bak"
# Insert at the end of the file
printf '%s\n' "ProcessSizeMax=0" >> "/etc/systemd/coredump.conf"
# Clean up after ourselves.
rm "/etc/systemd/coredump.conf.bak"

# END fix for 'coredump_disable_backtraces'

###############################################################################
# BEGIN fix (104 / 201) for 'disable_users_coredumps'
###############################################################################
(>&2 echo "Remediating rule 104/201: 'disable_users_coredumps'")
(>&2 echo "FIX FOR THIS RULE 'disable_users_coredumps' IS MISSING!")

# END fix for 'disable_users_coredumps'

###############################################################################
# BEGIN fix (105 / 201) for 'coredump_disable_storage'
###############################################################################
(>&2 echo "Remediating rule 105/201: 'coredump_disable_storage'")
if [ -e "/etc/systemd/coredump.conf" ] ; then
    LC_ALL=C sed -i "/^\s*Storage\s*=\s*/Id" "/etc/systemd/coredump.conf"
else
    touch "/etc/systemd/coredump.conf"
fi
cp "/etc/systemd/coredump.conf" "/etc/systemd/coredump.conf.bak"
# Insert at the end of the file
printf '%s\n' "Storage=none" >> "/etc/systemd/coredump.conf"
# Clean up after ourselves.
rm "/etc/systemd/coredump.conf.bak"

# END fix for 'coredump_disable_storage'

###############################################################################
# BEGIN fix (106 / 201) for 'sysctl_kernel_randomize_va_space'
###############################################################################
(>&2 echo "Remediating rule 106/201: 'sysctl_kernel_randomize_va_space'")
(>&2 echo "FIX FOR THIS RULE 'sysctl_kernel_randomize_va_space' IS MISSING!")

# END fix for 'sysctl_kernel_randomize_va_space'

###############################################################################
# BEGIN fix (107 / 201) for 'file_permissions_unauthorized_sgid'
###############################################################################
(>&2 echo "Remediating rule 107/201: 'file_permissions_unauthorized_sgid'")
(>&2 echo "FIX FOR THIS RULE 'file_permissions_unauthorized_sgid' IS MISSING!")

# END fix for 'file_permissions_unauthorized_sgid'

###############################################################################
# BEGIN fix (108 / 201) for 'file_permissions_ungroupowned'
###############################################################################
(>&2 echo "Remediating rule 108/201: 'file_permissions_ungroupowned'")
(>&2 echo "FIX FOR THIS RULE 'file_permissions_ungroupowned' IS MISSING!")

# END fix for 'file_permissions_ungroupowned'

###############################################################################
# BEGIN fix (109 / 201) for 'no_files_unowned_by_user'
###############################################################################
(>&2 echo "Remediating rule 109/201: 'no_files_unowned_by_user'")
(>&2 echo "FIX FOR THIS RULE 'no_files_unowned_by_user' IS MISSING!")

# END fix for 'no_files_unowned_by_user'

###############################################################################
# BEGIN fix (110 / 201) for 'file_permissions_unauthorized_suid'
###############################################################################
(>&2 echo "Remediating rule 110/201: 'file_permissions_unauthorized_suid'")
(>&2 echo "FIX FOR THIS RULE 'file_permissions_unauthorized_suid' IS MISSING!")

# END fix for 'file_permissions_unauthorized_suid'

###############################################################################
# BEGIN fix (111 / 201) for 'dir_perms_world_writable_sticky_bits'
###############################################################################
(>&2 echo "Remediating rule 111/201: 'dir_perms_world_writable_sticky_bits'")
(>&2 echo "FIX FOR THIS RULE 'dir_perms_world_writable_sticky_bits' IS MISSING!")

# END fix for 'dir_perms_world_writable_sticky_bits'

###############################################################################
# BEGIN fix (112 / 201) for 'file_permissions_unauthorized_world_writable'
###############################################################################
(>&2 echo "Remediating rule 112/201: 'file_permissions_unauthorized_world_writable'")

find / -xdev -type f -perm -002 -exec chmod o-w {} \;

# END fix for 'file_permissions_unauthorized_world_writable'

###############################################################################
# BEGIN fix (113 / 201) for 'file_permissions_backup_etc_shadow'
###############################################################################
(>&2 echo "Remediating rule 113/201: 'file_permissions_backup_etc_shadow'")


chmod 0000 /etc/shadow-

# END fix for 'file_permissions_backup_etc_shadow'

###############################################################################
# BEGIN fix (114 / 201) for 'file_owner_backup_etc_shadow'
###############################################################################
(>&2 echo "Remediating rule 114/201: 'file_owner_backup_etc_shadow'")


chown 0 /etc/shadow-

# END fix for 'file_owner_backup_etc_shadow'

###############################################################################
# BEGIN fix (115 / 201) for 'file_owner_etc_passwd'
###############################################################################
(>&2 echo "Remediating rule 115/201: 'file_owner_etc_passwd'")


chown 0 /etc/passwd

# END fix for 'file_owner_etc_passwd'

###############################################################################
# BEGIN fix (116 / 201) for 'file_owner_etc_gshadow'
###############################################################################
(>&2 echo "Remediating rule 116/201: 'file_owner_etc_gshadow'")


chown 0 /etc/gshadow

# END fix for 'file_owner_etc_gshadow'

###############################################################################
# BEGIN fix (117 / 201) for 'file_groupowner_etc_shadow'
###############################################################################
(>&2 echo "Remediating rule 117/201: 'file_groupowner_etc_shadow'")


chgrp 0 /etc/shadow

# END fix for 'file_groupowner_etc_shadow'

###############################################################################
# BEGIN fix (118 / 201) for 'file_groupowner_etc_passwd'
###############################################################################
(>&2 echo "Remediating rule 118/201: 'file_groupowner_etc_passwd'")


chgrp 0 /etc/passwd

# END fix for 'file_groupowner_etc_passwd'

###############################################################################
# BEGIN fix (119 / 201) for 'file_permissions_backup_etc_gshadow'
###############################################################################
(>&2 echo "Remediating rule 119/201: 'file_permissions_backup_etc_gshadow'")


chmod 0000 /etc/gshadow-

# END fix for 'file_permissions_backup_etc_gshadow'

###############################################################################
# BEGIN fix (120 / 201) for 'file_permissions_etc_group'
###############################################################################
(>&2 echo "Remediating rule 120/201: 'file_permissions_etc_group'")


chmod 0644 /etc/group

# END fix for 'file_permissions_etc_group'

###############################################################################
# BEGIN fix (121 / 201) for 'file_groupowner_backup_etc_gshadow'
###############################################################################
(>&2 echo "Remediating rule 121/201: 'file_groupowner_backup_etc_gshadow'")


chgrp 0 /etc/gshadow-

# END fix for 'file_groupowner_backup_etc_gshadow'

###############################################################################
# BEGIN fix (122 / 201) for 'file_groupowner_backup_etc_shadow'
###############################################################################
(>&2 echo "Remediating rule 122/201: 'file_groupowner_backup_etc_shadow'")


chgrp 0 /etc/shadow-

# END fix for 'file_groupowner_backup_etc_shadow'

###############################################################################
# BEGIN fix (123 / 201) for 'file_permissions_etc_shadow'
###############################################################################
(>&2 echo "Remediating rule 123/201: 'file_permissions_etc_shadow'")


chmod 0000 /etc/shadow

# END fix for 'file_permissions_etc_shadow'

###############################################################################
# BEGIN fix (124 / 201) for 'file_groupowner_etc_gshadow'
###############################################################################
(>&2 echo "Remediating rule 124/201: 'file_groupowner_etc_gshadow'")


chgrp 0 /etc/gshadow

# END fix for 'file_groupowner_etc_gshadow'

###############################################################################
# BEGIN fix (125 / 201) for 'file_permissions_backup_etc_passwd'
###############################################################################
(>&2 echo "Remediating rule 125/201: 'file_permissions_backup_etc_passwd'")


chmod 0644 /etc/passwd-

# END fix for 'file_permissions_backup_etc_passwd'

###############################################################################
# BEGIN fix (126 / 201) for 'file_owner_backup_etc_group'
###############################################################################
(>&2 echo "Remediating rule 126/201: 'file_owner_backup_etc_group'")


chown 0 /etc/group-

# END fix for 'file_owner_backup_etc_group'

###############################################################################
# BEGIN fix (127 / 201) for 'file_groupowner_backup_etc_group'
###############################################################################
(>&2 echo "Remediating rule 127/201: 'file_groupowner_backup_etc_group'")


chgrp 0 /etc/group-

# END fix for 'file_groupowner_backup_etc_group'

###############################################################################
# BEGIN fix (128 / 201) for 'file_permissions_backup_etc_group'
###############################################################################
(>&2 echo "Remediating rule 128/201: 'file_permissions_backup_etc_group'")


chmod 0644 /etc/group-

# END fix for 'file_permissions_backup_etc_group'

###############################################################################
# BEGIN fix (129 / 201) for 'file_owner_backup_etc_passwd'
###############################################################################
(>&2 echo "Remediating rule 129/201: 'file_owner_backup_etc_passwd'")


chown 0 /etc/passwd-

# END fix for 'file_owner_backup_etc_passwd'

###############################################################################
# BEGIN fix (130 / 201) for 'file_permissions_etc_gshadow'
###############################################################################
(>&2 echo "Remediating rule 130/201: 'file_permissions_etc_gshadow'")


chmod 0000 /etc/gshadow

# END fix for 'file_permissions_etc_gshadow'

###############################################################################
# BEGIN fix (131 / 201) for 'file_owner_backup_etc_gshadow'
###############################################################################
(>&2 echo "Remediating rule 131/201: 'file_owner_backup_etc_gshadow'")


chown 0 /etc/gshadow-

# END fix for 'file_owner_backup_etc_gshadow'

###############################################################################
# BEGIN fix (132 / 201) for 'file_owner_etc_shadow'
###############################################################################
(>&2 echo "Remediating rule 132/201: 'file_owner_etc_shadow'")


chown 0 /etc/shadow

# END fix for 'file_owner_etc_shadow'

###############################################################################
# BEGIN fix (133 / 201) for 'file_owner_etc_group'
###############################################################################
(>&2 echo "Remediating rule 133/201: 'file_owner_etc_group'")


chown 0 /etc/group

# END fix for 'file_owner_etc_group'

###############################################################################
# BEGIN fix (134 / 201) for 'file_permissions_etc_passwd'
###############################################################################
(>&2 echo "Remediating rule 134/201: 'file_permissions_etc_passwd'")


chmod 0644 /etc/passwd

# END fix for 'file_permissions_etc_passwd'

###############################################################################
# BEGIN fix (135 / 201) for 'file_groupowner_backup_etc_passwd'
###############################################################################
(>&2 echo "Remediating rule 135/201: 'file_groupowner_backup_etc_passwd'")


chgrp 0 /etc/passwd-

# END fix for 'file_groupowner_backup_etc_passwd'

###############################################################################
# BEGIN fix (136 / 201) for 'file_groupowner_etc_group'
###############################################################################
(>&2 echo "Remediating rule 136/201: 'file_groupowner_etc_group'")


chgrp 0 /etc/group

# END fix for 'file_groupowner_etc_group'

###############################################################################
# BEGIN fix (137 / 201) for 'service_httpd_disabled'
###############################################################################
(>&2 echo "Remediating rule 137/201: 'service_httpd_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'httpd.service'
"$SYSTEMCTL_EXEC" disable 'httpd.service'
"$SYSTEMCTL_EXEC" mask 'httpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^httpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'httpd.socket'
    "$SYSTEMCTL_EXEC" disable 'httpd.socket'
    "$SYSTEMCTL_EXEC" mask 'httpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'httpd.service' || true

# END fix for 'service_httpd_disabled'

###############################################################################
# BEGIN fix (138 / 201) for 'service_squid_disabled'
###############################################################################
(>&2 echo "Remediating rule 138/201: 'service_squid_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'squid.service'
"$SYSTEMCTL_EXEC" disable 'squid.service'
"$SYSTEMCTL_EXEC" mask 'squid.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^squid.socket'; then
    "$SYSTEMCTL_EXEC" stop 'squid.socket'
    "$SYSTEMCTL_EXEC" disable 'squid.socket'
    "$SYSTEMCTL_EXEC" mask 'squid.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'squid.service' || true

# END fix for 'service_squid_disabled'

###############################################################################
# BEGIN fix (139 / 201) for 'file_permissions_sshd_pub_key'
###############################################################################
(>&2 echo "Remediating rule 139/201: 'file_permissions_sshd_pub_key'")


readarray -t files < <(find /etc/ssh/)
for file in "${files[@]}"; do
    if basename $file | grep -q '^.*.pub$'; then
        chmod 0644 $file
    fi    
done

# END fix for 'file_permissions_sshd_pub_key'

###############################################################################
# BEGIN fix (140 / 201) for 'file_permissions_sshd_config'
###############################################################################
(>&2 echo "Remediating rule 140/201: 'file_permissions_sshd_config'")


chmod 0600 /etc/ssh/sshd_config

# END fix for 'file_permissions_sshd_config'

###############################################################################
# BEGIN fix (141 / 201) for 'file_groupowner_sshd_config'
###############################################################################
(>&2 echo "Remediating rule 141/201: 'file_groupowner_sshd_config'")


chgrp 0 /etc/ssh/sshd_config

# END fix for 'file_groupowner_sshd_config'

###############################################################################
# BEGIN fix (142 / 201) for 'file_owner_sshd_config'
###############################################################################
(>&2 echo "Remediating rule 142/201: 'file_owner_sshd_config'")


chown 0 /etc/ssh/sshd_config

# END fix for 'file_owner_sshd_config'

###############################################################################
# BEGIN fix (143 / 201) for 'file_permissions_sshd_private_key'
###############################################################################
(>&2 echo "Remediating rule 143/201: 'file_permissions_sshd_private_key'")


readarray -t files < <(find /etc/ssh/)
for file in "${files[@]}"; do
    if basename $file | grep -q '^.*_key$'; then
        chmod 0600 $file
    fi    
done

# END fix for 'file_permissions_sshd_private_key'

###############################################################################
# BEGIN fix (144 / 201) for 'sshd_do_not_permit_user_env'
###############################################################################
(>&2 echo "Remediating rule 144/201: 'sshd_do_not_permit_user_env'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PermitUserEnvironment\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PermitUserEnvironment no" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "PermitUserEnvironment no" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_do_not_permit_user_env'

###############################################################################
# BEGIN fix (145 / 201) for 'sshd_disable_tcp_forwarding'
###############################################################################
(>&2 echo "Remediating rule 145/201: 'sshd_disable_tcp_forwarding'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*AllowTcpForwarding\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "AllowTcpForwarding no" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "AllowTcpForwarding no" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_disable_tcp_forwarding'

###############################################################################
# BEGIN fix (146 / 201) for 'sshd_set_keepalive'
###############################################################################
(>&2 echo "Remediating rule 146/201: 'sshd_set_keepalive'")

var_sshd_set_keepalive="0"

if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*ClientAliveCountMax\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "ClientAliveCountMax $var_sshd_set_keepalive" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "ClientAliveCountMax $var_sshd_set_keepalive" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_set_keepalive'

###############################################################################
# BEGIN fix (147 / 201) for 'sshd_set_max_auth_tries'
###############################################################################
(>&2 echo "Remediating rule 147/201: 'sshd_set_max_auth_tries'")

sshd_max_auth_tries_value="4"

if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*MaxAuthTries\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "MaxAuthTries $sshd_max_auth_tries_value" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "MaxAuthTries $sshd_max_auth_tries_value" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_set_max_auth_tries'

###############################################################################
# BEGIN fix (148 / 201) for 'sshd_set_loglevel_info'
###############################################################################
(>&2 echo "Remediating rule 148/201: 'sshd_set_loglevel_info'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*LogLevel\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "LogLevel INFO" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "LogLevel INFO" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_set_loglevel_info'

###############################################################################
# BEGIN fix (149 / 201) for 'sshd_use_strong_ciphers'
###############################################################################
(>&2 echo "Remediating rule 149/201: 'sshd_use_strong_ciphers'")

if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*Ciphers\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "Ciphers aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "Ciphers aes128-ctr,aes192-ctr,aes256-ctr,chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_use_strong_ciphers'

###############################################################################
# BEGIN fix (150 / 201) for 'sshd_use_strong_macs'
###############################################################################
(>&2 echo "Remediating rule 150/201: 'sshd_use_strong_macs'")

if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*MACs\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,hmac-ripemd160" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,hmac-ripemd160" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_use_strong_macs'

###############################################################################
# BEGIN fix (151 / 201) for 'disable_host_auth'
###############################################################################
(>&2 echo "Remediating rule 151/201: 'disable_host_auth'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*HostbasedAuthentication\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "HostbasedAuthentication no" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "HostbasedAuthentication no" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'disable_host_auth'

###############################################################################
# BEGIN fix (152 / 201) for 'sshd_disable_root_login'
###############################################################################
(>&2 echo "Remediating rule 152/201: 'sshd_disable_root_login'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PermitRootLogin\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PermitRootLogin no" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "PermitRootLogin no" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_disable_root_login'

###############################################################################
# BEGIN fix (153 / 201) for 'sshd_disable_empty_passwords'
###############################################################################
(>&2 echo "Remediating rule 153/201: 'sshd_disable_empty_passwords'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*PermitEmptyPasswords\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "PermitEmptyPasswords no" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "PermitEmptyPasswords no" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_disable_empty_passwords'

###############################################################################
# BEGIN fix (154 / 201) for 'sshd_set_idle_timeout'
###############################################################################
(>&2 echo "Remediating rule 154/201: 'sshd_set_idle_timeout'")

sshd_idle_timeout_value="300"
# Function to replace configuration setting in config file or add the configuration setting if
# it does not exist.
#
# Expects arguments:
#
# config_file:		Configuration file that will be modified
# key:			Configuration option to change
# value:		Value of the configuration option to change
# cce:			The CCE identifier or '@CCENUM@' if no CCE identifier exists
# format:		The printf-like format string that will be given stripped key and value as arguments,
#			so e.g. '%s=%s' will result in key=value subsitution (i.e. without spaces around =)
#
# Optional arugments:
#
# format:		Optional argument to specify the format of how key/value should be
# 			modified/appended in the configuration file. The default is key = value.
#
# Example Call(s):
#
#     With default format of 'key = value':
#     replace_or_append '/etc/sysctl.conf' '^kernel.randomize_va_space' '2' '@CCENUM@'
#
#     With custom key/value format:
#     replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' 'disabled' '@CCENUM@' '%s=%s'
#
#     With a variable:
#     replace_or_append '/etc/sysconfig/selinux' '^SELINUX=' $var_selinux_state '@CCENUM@' '%s=%s'
#
function replace_or_append {
  local default_format='%s = %s' case_insensitive_mode=yes sed_case_insensitive_option='' grep_case_insensitive_option=''
  local config_file=$1
  local key=$2
  local value=$3
  local cce=$4
  local format=$5

  if [ "$case_insensitive_mode" = yes ]; then
    sed_case_insensitive_option="i"
    grep_case_insensitive_option="-i"
  fi
  [ -n "$format" ] || format="$default_format"
  # Check sanity of the input
  [ $# -ge "3" ] || { echo "Usage: replace_or_append <config_file_location> <key_to_search> <new_value> [<CCE number or literal '@CCENUM@' if unknown>] [printf-like format, default is '$default_format']" >&2; exit 1; }

  # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed.
  # Otherwise, regular sed command will do.
  sed_command=('sed' '-i')
  if test -L "$config_file"; then
    sed_command+=('--follow-symlinks')
  fi

  # Test that the cce arg is not empty or does not equal @CCENUM@.
  # If @CCENUM@ exists, it means that there is no CCE assigned.
  if [ -n "$cce" ] && [ "$cce" != '@CCENUM@' ]; then
    cce="${cce}"
  else
    cce="CCE"
  fi

  # Strip any search characters in the key arg so that the key can be replaced without
  # adding any search characters to the config file.
  stripped_key=$(sed 's/[\^=\$,;+]*//g' <<< "$key")

  # shellcheck disable=SC2059
  printf -v formatted_output "$format" "$stripped_key" "$value"

  # If the key exists, change it. Otherwise, add it to the config_file.
  # We search for the key string followed by a word boundary (matched by \>),
  # so if we search for 'setting', 'setting2' won't match.
  if LC_ALL=C grep -q -m 1 $grep_case_insensitive_option -e "${key}\\>" "$config_file"; then
    "${sed_command[@]}" "s/${key}\\>.*/$formatted_output/g$sed_case_insensitive_option" "$config_file"
  else
    # \n is precaution for case where file ends without trailing newline
    printf '\n# Per %s: Set %s in %s\n' "$cce" "$formatted_output" "$config_file" >> "$config_file"
    printf '%s\n' "$formatted_output" >> "$config_file"
  fi
}
replace_or_append '/etc/ssh/sshd_config' '^ClientAliveInterval' $sshd_idle_timeout_value '' '%s %s'

# END fix for 'sshd_set_idle_timeout'

###############################################################################
# BEGIN fix (155 / 201) for 'sshd_disable_rhosts'
###############################################################################
(>&2 echo "Remediating rule 155/201: 'sshd_disable_rhosts'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*IgnoreRhosts\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "IgnoreRhosts yes" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "IgnoreRhosts yes" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_disable_rhosts'

###############################################################################
# BEGIN fix (156 / 201) for 'sshd_enable_warning_banner'
###############################################################################
(>&2 echo "Remediating rule 156/201: 'sshd_enable_warning_banner'")
if [ -e "/etc/ssh/sshd_config" ] ; then
    LC_ALL=C sed -i "/^\s*Banner\s\+/Id" "/etc/ssh/sshd_config"
else
    touch "/etc/ssh/sshd_config"
fi
cp "/etc/ssh/sshd_config" "/etc/ssh/sshd_config.bak"
# Insert before the line matching the regex '^Match'.
line_number="$(LC_ALL=C grep -n "^Match" "/etc/ssh/sshd_config.bak" | LC_ALL=C sed 's/:.*//g')"
if [ -z "$line_number" ]; then
    # There was no match of '^Match', insert at
    # the end of the file.
    printf '%s\n' "Banner /etc/issue" >> "/etc/ssh/sshd_config"
else
    head -n "$(( line_number - 1 ))" "/etc/ssh/sshd_config.bak" > "/etc/ssh/sshd_config"
    printf '%s\n' "Banner /etc/issue" >> "/etc/ssh/sshd_config"
    tail -n "+$(( line_number ))" "/etc/ssh/sshd_config.bak" >> "/etc/ssh/sshd_config"
fi
# Clean up after ourselves.
rm "/etc/ssh/sshd_config.bak"

# END fix for 'sshd_enable_warning_banner'

###############################################################################
# BEGIN fix (157 / 201) for 'package_openldap-servers_removed'
###############################################################################
(>&2 echo "Remediating rule 157/201: 'package_openldap-servers_removed'")

# CAUTION: This remediation script will remove openldap-servers
#	   from the system, and may remove any packages
#	   that depend on openldap-servers. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_openldap-servers_removed'

###############################################################################
# BEGIN fix (158 / 201) for 'package_openldap-clients_removed'
###############################################################################
(>&2 echo "Remediating rule 158/201: 'package_openldap-clients_removed'")

# CAUTION: This remediation script will remove openldap-clients
#	   from the system, and may remove any packages
#	   that depend on openldap-clients. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_openldap-clients_removed'

###############################################################################
# BEGIN fix (159 / 201) for 'package_chrony_installed'
###############################################################################
(>&2 echo "Remediating rule 159/201: 'package_chrony_installed'")
(>&2 echo "FIX FOR THIS RULE 'package_chrony_installed' IS MISSING!")

# END fix for 'package_chrony_installed'

###############################################################################
# BEGIN fix (160 / 201) for 'service_chronyd_enabled'
###############################################################################
(>&2 echo "Remediating rule 160/201: 'service_chronyd_enabled'")
(>&2 echo "FIX FOR THIS RULE 'service_chronyd_enabled' IS MISSING!")

# END fix for 'service_chronyd_enabled'

###############################################################################
# BEGIN fix (161 / 201) for 'chronyd_specify_remote_server'
###############################################################################
(>&2 echo "Remediating rule 161/201: 'chronyd_specify_remote_server'")

var_multiple_time_servers="0.pool.ntp.org,1.pool.ntp.org,2.pool.ntp.org,3.pool.ntp.org"

config_file="/etc/chrony.conf"

if ! grep -q '^[\s]*(?:server|pool)[\s]+[\w]+' "$config_file" ; then
  if ! grep -q '#[[:space:]]*server' "$config_file" ; then
    for server in $(echo "$var_multiple_time_servers" | tr ',' '\n') ; do
      printf '\nserver %s' "$server" >> "$config_file"
    done
  else
    sed -i 's/#[ \t]*server/server/g' "$config_file"
  fi
fi

# END fix for 'chronyd_specify_remote_server'

###############################################################################
# BEGIN fix (162 / 201) for 'chronyd_run_as_chrony_user'
###############################################################################
(>&2 echo "Remediating rule 162/201: 'chronyd_run_as_chrony_user'")
(>&2 echo "FIX FOR THIS RULE 'chronyd_run_as_chrony_user' IS MISSING!")

# END fix for 'chronyd_run_as_chrony_user'

###############################################################################
# BEGIN fix (163 / 201) for 'file_permissions_cron_monthly'
###############################################################################
(>&2 echo "Remediating rule 163/201: 'file_permissions_cron_monthly'")


chmod 0700 /etc/cron.monthly/

# END fix for 'file_permissions_cron_monthly'

###############################################################################
# BEGIN fix (164 / 201) for 'file_groupowner_cron_weekly'
###############################################################################
(>&2 echo "Remediating rule 164/201: 'file_groupowner_cron_weekly'")


chgrp 0 /etc/cron.weekly/

# END fix for 'file_groupowner_cron_weekly'

###############################################################################
# BEGIN fix (165 / 201) for 'file_owner_cron_monthly'
###############################################################################
(>&2 echo "Remediating rule 165/201: 'file_owner_cron_monthly'")


chown 0 /etc/cron.monthly/

# END fix for 'file_owner_cron_monthly'

###############################################################################
# BEGIN fix (166 / 201) for 'file_permissions_cron_daily'
###############################################################################
(>&2 echo "Remediating rule 166/201: 'file_permissions_cron_daily'")


chmod 0700 /etc/cron.daily/

# END fix for 'file_permissions_cron_daily'

###############################################################################
# BEGIN fix (167 / 201) for 'file_permissions_cron_hourly'
###############################################################################
(>&2 echo "Remediating rule 167/201: 'file_permissions_cron_hourly'")


chmod 0700 /etc/cron.hourly/

# END fix for 'file_permissions_cron_hourly'

###############################################################################
# BEGIN fix (168 / 201) for 'file_groupowner_crontab'
###############################################################################
(>&2 echo "Remediating rule 168/201: 'file_groupowner_crontab'")


chgrp 0 /etc/crontab

# END fix for 'file_groupowner_crontab'

###############################################################################
# BEGIN fix (169 / 201) for 'file_owner_cron_d'
###############################################################################
(>&2 echo "Remediating rule 169/201: 'file_owner_cron_d'")


chown 0 /etc/cron.d/

# END fix for 'file_owner_cron_d'

###############################################################################
# BEGIN fix (170 / 201) for 'file_owner_crontab'
###############################################################################
(>&2 echo "Remediating rule 170/201: 'file_owner_crontab'")


chown 0 /etc/crontab

# END fix for 'file_owner_crontab'

###############################################################################
# BEGIN fix (171 / 201) for 'file_owner_cron_weekly'
###############################################################################
(>&2 echo "Remediating rule 171/201: 'file_owner_cron_weekly'")


chown 0 /etc/cron.weekly/

# END fix for 'file_owner_cron_weekly'

###############################################################################
# BEGIN fix (172 / 201) for 'file_owner_cron_hourly'
###############################################################################
(>&2 echo "Remediating rule 172/201: 'file_owner_cron_hourly'")


chown 0 /etc/cron.hourly/

# END fix for 'file_owner_cron_hourly'

###############################################################################
# BEGIN fix (173 / 201) for 'file_permissions_cron_weekly'
###############################################################################
(>&2 echo "Remediating rule 173/201: 'file_permissions_cron_weekly'")


chmod 0700 /etc/cron.weekly/

# END fix for 'file_permissions_cron_weekly'

###############################################################################
# BEGIN fix (174 / 201) for 'file_groupowner_cron_daily'
###############################################################################
(>&2 echo "Remediating rule 174/201: 'file_groupowner_cron_daily'")


chgrp 0 /etc/cron.daily/

# END fix for 'file_groupowner_cron_daily'

###############################################################################
# BEGIN fix (175 / 201) for 'file_groupowner_cron_monthly'
###############################################################################
(>&2 echo "Remediating rule 175/201: 'file_groupowner_cron_monthly'")


chgrp 0 /etc/cron.monthly/

# END fix for 'file_groupowner_cron_monthly'

###############################################################################
# BEGIN fix (176 / 201) for 'file_groupowner_cron_d'
###############################################################################
(>&2 echo "Remediating rule 176/201: 'file_groupowner_cron_d'")


chgrp 0 /etc/cron.d/

# END fix for 'file_groupowner_cron_d'

###############################################################################
# BEGIN fix (177 / 201) for 'file_permissions_crontab'
###############################################################################
(>&2 echo "Remediating rule 177/201: 'file_permissions_crontab'")


chmod 0600 /etc/crontab

# END fix for 'file_permissions_crontab'

###############################################################################
# BEGIN fix (178 / 201) for 'file_groupowner_cron_hourly'
###############################################################################
(>&2 echo "Remediating rule 178/201: 'file_groupowner_cron_hourly'")


chgrp 0 /etc/cron.hourly/

# END fix for 'file_groupowner_cron_hourly'

###############################################################################
# BEGIN fix (179 / 201) for 'file_permissions_cron_d'
###############################################################################
(>&2 echo "Remediating rule 179/201: 'file_permissions_cron_d'")


chmod 0700 /etc/cron.d/

# END fix for 'file_permissions_cron_d'

###############################################################################
# BEGIN fix (180 / 201) for 'file_owner_cron_daily'
###############################################################################
(>&2 echo "Remediating rule 180/201: 'file_owner_cron_daily'")


chown 0 /etc/cron.daily/

# END fix for 'file_owner_cron_daily'

###############################################################################
# BEGIN fix (181 / 201) for 'service_rsyncd_disabled'
###############################################################################
(>&2 echo "Remediating rule 181/201: 'service_rsyncd_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rsyncd.service'
"$SYSTEMCTL_EXEC" disable 'rsyncd.service'
"$SYSTEMCTL_EXEC" mask 'rsyncd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rsyncd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rsyncd.socket'
    "$SYSTEMCTL_EXEC" disable 'rsyncd.socket'
    "$SYSTEMCTL_EXEC" mask 'rsyncd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rsyncd.service' || true

# END fix for 'service_rsyncd_disabled'

###############################################################################
# BEGIN fix (182 / 201) for 'package_talk_removed'
###############################################################################
(>&2 echo "Remediating rule 182/201: 'package_talk_removed'")

# CAUTION: This remediation script will remove talk
#	   from the system, and may remove any packages
#	   that depend on talk. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_talk_removed'

###############################################################################
# BEGIN fix (183 / 201) for 'package_telnet_removed'
###############################################################################
(>&2 echo "Remediating rule 183/201: 'package_telnet_removed'")

# CAUTION: This remediation script will remove telnet
#	   from the system, and may remove any packages
#	   that depend on telnet. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_telnet_removed'

###############################################################################
# BEGIN fix (184 / 201) for 'service_xinetd_disabled'
###############################################################################
(>&2 echo "Remediating rule 184/201: 'service_xinetd_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'xinetd.service'
"$SYSTEMCTL_EXEC" disable 'xinetd.service'
"$SYSTEMCTL_EXEC" mask 'xinetd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^xinetd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'xinetd.socket'
    "$SYSTEMCTL_EXEC" disable 'xinetd.socket'
    "$SYSTEMCTL_EXEC" mask 'xinetd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'xinetd.service' || true

# END fix for 'service_xinetd_disabled'

###############################################################################
# BEGIN fix (185 / 201) for 'package_rsh_removed'
###############################################################################
(>&2 echo "Remediating rule 185/201: 'package_rsh_removed'")

# CAUTION: This remediation script will remove rsh
#	   from the system, and may remove any packages
#	   that depend on rsh. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_rsh_removed'

###############################################################################
# BEGIN fix (186 / 201) for 'package_ypbind_removed'
###############################################################################
(>&2 echo "Remediating rule 186/201: 'package_ypbind_removed'")

# CAUTION: This remediation script will remove ypbind
#	   from the system, and may remove any packages
#	   that depend on ypbind. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_ypbind_removed'

###############################################################################
# BEGIN fix (187 / 201) for 'package_ypserv_removed'
###############################################################################
(>&2 echo "Remediating rule 187/201: 'package_ypserv_removed'")

# CAUTION: This remediation script will remove ypserv
#	   from the system, and may remove any packages
#	   that depend on ypserv. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_ypserv_removed'

###############################################################################
# BEGIN fix (188 / 201) for 'service_snmpd_disabled'
###############################################################################
(>&2 echo "Remediating rule 188/201: 'service_snmpd_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'snmpd.service'
"$SYSTEMCTL_EXEC" disable 'snmpd.service'
"$SYSTEMCTL_EXEC" mask 'snmpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^snmpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'snmpd.socket'
    "$SYSTEMCTL_EXEC" disable 'snmpd.socket'
    "$SYSTEMCTL_EXEC" mask 'snmpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'snmpd.service' || true

# END fix for 'service_snmpd_disabled'

###############################################################################
# BEGIN fix (189 / 201) for 'service_dhcpd_disabled'
###############################################################################
(>&2 echo "Remediating rule 189/201: 'service_dhcpd_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'dhcpd.service'
"$SYSTEMCTL_EXEC" disable 'dhcpd.service'
"$SYSTEMCTL_EXEC" mask 'dhcpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^dhcpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'dhcpd.socket'
    "$SYSTEMCTL_EXEC" disable 'dhcpd.socket'
    "$SYSTEMCTL_EXEC" mask 'dhcpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'dhcpd.service' || true

# END fix for 'service_dhcpd_disabled'

###############################################################################
# BEGIN fix (190 / 201) for 'service_avahi-daemon_disabled'
###############################################################################
(>&2 echo "Remediating rule 190/201: 'service_avahi-daemon_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'avahi-daemon.service'
"$SYSTEMCTL_EXEC" disable 'avahi-daemon.service'
"$SYSTEMCTL_EXEC" mask 'avahi-daemon.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^avahi-daemon.socket'; then
    "$SYSTEMCTL_EXEC" stop 'avahi-daemon.socket'
    "$SYSTEMCTL_EXEC" disable 'avahi-daemon.socket'
    "$SYSTEMCTL_EXEC" mask 'avahi-daemon.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'avahi-daemon.service' || true

# END fix for 'service_avahi-daemon_disabled'

###############################################################################
# BEGIN fix (191 / 201) for 'service_cups_disabled'
###############################################################################
(>&2 echo "Remediating rule 191/201: 'service_cups_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'cups.service'
"$SYSTEMCTL_EXEC" disable 'cups.service'
"$SYSTEMCTL_EXEC" mask 'cups.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^cups.socket'; then
    "$SYSTEMCTL_EXEC" stop 'cups.socket'
    "$SYSTEMCTL_EXEC" disable 'cups.socket'
    "$SYSTEMCTL_EXEC" mask 'cups.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'cups.service' || true

# END fix for 'service_cups_disabled'

###############################################################################
# BEGIN fix (192 / 201) for 'postfix_network_listening_disabled'
###############################################################################
(>&2 echo "Remediating rule 192/201: 'postfix_network_listening_disabled'")
(>&2 echo "FIX FOR THIS RULE 'postfix_network_listening_disabled' IS MISSING!")

# END fix for 'postfix_network_listening_disabled'

###############################################################################
# BEGIN fix (193 / 201) for 'service_dovecot_disabled'
###############################################################################
(>&2 echo "Remediating rule 193/201: 'service_dovecot_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'dovecot.service'
"$SYSTEMCTL_EXEC" disable 'dovecot.service'
"$SYSTEMCTL_EXEC" mask 'dovecot.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^dovecot.socket'; then
    "$SYSTEMCTL_EXEC" stop 'dovecot.socket'
    "$SYSTEMCTL_EXEC" disable 'dovecot.socket'
    "$SYSTEMCTL_EXEC" mask 'dovecot.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'dovecot.service' || true

# END fix for 'service_dovecot_disabled'

###############################################################################
# BEGIN fix (194 / 201) for 'package_telnetd_removed'
###############################################################################
(>&2 echo "Remediating rule 194/201: 'package_telnetd_removed'")

# CAUTION: This remediation script will remove telnetd
#	   from the system, and may remove any packages
#	   that depend on telnetd. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_telnetd_removed'

###############################################################################
# BEGIN fix (195 / 201) for 'service_smb_disabled'
###############################################################################
(>&2 echo "Remediating rule 195/201: 'service_smb_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'smb.service'
"$SYSTEMCTL_EXEC" disable 'smb.service'
"$SYSTEMCTL_EXEC" mask 'smb.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^smb.socket'; then
    "$SYSTEMCTL_EXEC" stop 'smb.socket'
    "$SYSTEMCTL_EXEC" disable 'smb.socket'
    "$SYSTEMCTL_EXEC" mask 'smb.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'smb.service' || true

# END fix for 'service_smb_disabled'

###############################################################################
# BEGIN fix (196 / 201) for 'package_xorg-x11-server-common_removed'
###############################################################################
(>&2 echo "Remediating rule 196/201: 'package_xorg-x11-server-common_removed'")

# CAUTION: This remediation script will remove xorg-x11-server-common
#	   from the system, and may remove any packages
#	   that depend on xorg-x11-server-common. Execute this
#	   remediation AFTER testing on a non-production
#	   system!

printf '%s\n' "Can't generate a remediation for zypper" >&2
exit 1

# END fix for 'package_xorg-x11-server-common_removed'

###############################################################################
# BEGIN fix (197 / 201) for 'xwindows_runlevel_target'
###############################################################################
(>&2 echo "Remediating rule 197/201: 'xwindows_runlevel_target'")

systemctl set-default multi-user.target

# END fix for 'xwindows_runlevel_target'

###############################################################################
# BEGIN fix (198 / 201) for 'service_named_disabled'
###############################################################################
(>&2 echo "Remediating rule 198/201: 'service_named_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'named.service'
"$SYSTEMCTL_EXEC" disable 'named.service'
"$SYSTEMCTL_EXEC" mask 'named.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^named.socket'; then
    "$SYSTEMCTL_EXEC" stop 'named.socket'
    "$SYSTEMCTL_EXEC" disable 'named.socket'
    "$SYSTEMCTL_EXEC" mask 'named.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'named.service' || true

# END fix for 'service_named_disabled'

###############################################################################
# BEGIN fix (199 / 201) for 'service_nfs_disabled'
###############################################################################
(>&2 echo "Remediating rule 199/201: 'service_nfs_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'nfs.service'
"$SYSTEMCTL_EXEC" disable 'nfs.service'
"$SYSTEMCTL_EXEC" mask 'nfs.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^nfs.socket'; then
    "$SYSTEMCTL_EXEC" stop 'nfs.socket'
    "$SYSTEMCTL_EXEC" disable 'nfs.socket'
    "$SYSTEMCTL_EXEC" mask 'nfs.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'nfs.service' || true

# END fix for 'service_nfs_disabled'

###############################################################################
# BEGIN fix (200 / 201) for 'service_rpcbind_disabled'
###############################################################################
(>&2 echo "Remediating rule 200/201: 'service_rpcbind_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'rpcbind.service'
"$SYSTEMCTL_EXEC" disable 'rpcbind.service'
"$SYSTEMCTL_EXEC" mask 'rpcbind.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^rpcbind.socket'; then
    "$SYSTEMCTL_EXEC" stop 'rpcbind.socket'
    "$SYSTEMCTL_EXEC" disable 'rpcbind.socket'
    "$SYSTEMCTL_EXEC" mask 'rpcbind.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'rpcbind.service' || true

# END fix for 'service_rpcbind_disabled'

###############################################################################
# BEGIN fix (201 / 201) for 'service_vsftpd_disabled'
###############################################################################
(>&2 echo "Remediating rule 201/201: 'service_vsftpd_disabled'")


SYSTEMCTL_EXEC='/usr/bin/systemctl'
"$SYSTEMCTL_EXEC" stop 'vsftpd.service'
"$SYSTEMCTL_EXEC" disable 'vsftpd.service'
"$SYSTEMCTL_EXEC" mask 'vsftpd.service'
# Disable socket activation if we have a unit file for it
if "$SYSTEMCTL_EXEC" list-unit-files | grep -q '^vsftpd.socket'; then
    "$SYSTEMCTL_EXEC" stop 'vsftpd.socket'
    "$SYSTEMCTL_EXEC" disable 'vsftpd.socket'
    "$SYSTEMCTL_EXEC" mask 'vsftpd.socket'
fi
# The service may not be running because it has been started and failed,
# so let's reset the state so OVAL checks pass.
# Service should be 'inactive', not 'failed' after reboot though.
"$SYSTEMCTL_EXEC" reset-failed 'vsftpd.service' || true

# END fix for 'service_vsftpd_disabled'

